/** Folder layout
 * cmd: npx directory-tree-ascii . -b node_modules .git

> tsmis-core@1.0.0 npx
> daa . -b node_modules .git

```
└─ .
   ├─ API.md
   ├─ coverage
   │  ├─ clover.xml
   │  ├─ coverage-final.json
   │  ├─ lcov-report
   │  │  ├─ base.css
   │  │  ├─ block-navigation.js
   │  │  ├─ container
   │  │  │  ├─ Container.js.html
   │  │  │  └─ index.html
   │  │  ├─ errors
   │  │  │  ├─ Error.js.html
   │  │  │  ├─ ErrorSystem.js.html
   │  │  │  ├─ index.html
   │  │  │  ├─ index.js.html
   │  │  │  ├─ integrations
   │  │  │  │  ├─ IFrameworkIntegration.js.html
   │  │  │  │  ├─ fastify
   │  │  │  │  │  ├─ FastifyIntegration.js.html
   │  │  │  │  │  ├─ handler.js.html
   │  │  │  │  │  ├─ index.html
   │  │  │  │  │  └─ serializer.js.html
   │  │  │  │  └─ index.html
   │  │  │  └─ types
   │  │  │     ├─ AccessError.js.html
   │  │  │     ├─ AuthError.js.html
   │  │  │     ├─ ConfigError.js.html
   │  │  │     ├─ EventError.js.html
   │  │  │     ├─ ModuleError.js.html
   │  │  │     ├─ NetworkError.js.html
   │  │  │     ├─ ServiceError.js.html
   │  │  │     ├─ ValidationError.js.html
   │  │  │     ├─ index.html
   │  │  │     └─ index.js.html
   │  │  ├─ event
   │  │  │  ├─ EventBus.js.html
   │  │  │  ├─ EventBusSystem.js.html
   │  │  │  └─ index.html
   │  │  ├─ favicon.png
   │  │  ├─ index.html
   │  │  ├─ module
   │  │  │  ├─ Module.js.html
   │  │  │  ├─ ModuleSystem.js.html
   │  │  │  └─ index.html
   │  │  ├─ prettify.css
   │  │  ├─ prettify.js
   │  │  ├─ sort-arrow-sprite.png
   │  │  └─ sorter.js
   │  └─ lcov.info
   ├─ dev
   │  ├─ current_code.txt
   │  ├─ docs
   │  │  ├─ claude_prompt.md
   │  │  ├─ dev_manual.md
   │  │  ├─ dev_roadmap.md
   │  │  ├─ dev_test_instructions.md
   │  │  └─ technical.md
   │  └─ tools
   │     ├─ combined-files.js
   │     ├─ reverse-files.js
   │     └─ setup-project.js
   ├─ package-lock.json
   ├─ package.json
   ├─ src
   │  ├─ README.md
   │  ├─ app.js
   │  ├─ core
   │  │  ├─ container
   │  │  │  ├─ Container.js
   │  │  │  └─ container-system-docs.md
   │  │  ├─ errors
   │  │  │  ├─ Error.js
   │  │  │  ├─ ErrorSystem.js
   │  │  │  ├─ error-system-docs.md
   │  │  │  ├─ index.js
   │  │  │  ├─ integrations
   │  │  │  │  ├─ IFrameworkIntegration.js
   │  │  │  │  └─ fastify
   │  │  │  │     ├─ FastifyIntegration.js
   │  │  │  │     ├─ handler.js
   │  │  │  │     ├─ index.js
   │  │  │  │     └─ serializer.js
   │  │  │  └─ types
   │  │  │     ├─ AccessError.js
   │  │  │     ├─ AuthError.js
   │  │  │     ├─ ConfigError.js
   │  │  │     ├─ EventError.js
   │  │  │     ├─ ModuleError.js
   │  │  │     ├─ NetworkError.js
   │  │  │     ├─ ServiceError.js
   │  │  │     ├─ ValidationError.js
   │  │  │     └─ index.js
   │  │  ├─ event
   │  │  │  ├─ EventBus.js
   │  │  │  ├─ EventBusSystem.js
   │  │  │  └─ event-bus-docs.md
   │  │  ├─ module
   │  │  │  ├─ Module.js
   │  │  │  ├─ ModuleSystem.js
   │  │  │  └─ module-system-docs.md
   │  │  ├─ service
   │  │  └─ validation
   │  ├─ modules
   │  └─ services
   │     ├─ cache
   │     ├─ database
   │     ├─ email
   │     ├─ ip
   │     └─ logger
   └─ tests
      ├─ core
      │  ├─ container
      │  │  └─ Container.test.js
      │  ├─ errors
      │  │  ├─ Error.test.js
      │  │  ├─ ErrorSystem.test.js
      │  │  ├─ integration.test.js
      │  │  ├─ integrations
      │  │  │  ├─ IFrameworkIntegration.test.js
      │  │  │  └─ fastify
      │  │  │     ├─ FastifyIntegration.test.js
      │  │  │     ├─ handler.test.js
      │  │  │     └─ serializer.test.js
      │  │  └─ types
      │  │     ├─ ErrorTypes.test.js
      │  │     └─ index.test.js
      │  ├─ event
      │  │  ├─ EventBus.test.js
      │  │  └─ EventBusSystem.test.js
      │  └─ module
      │     ├─ Module.test.js
      │     └─ ModuleSystem.test.js
      └─ index.test.js

```
*/


// src/README.md

# TSMIS Core Runtime

> A modern, test-driven, event-centric, enterprise-grade runtime for building modular Node.js applications.

![TSMIS Core Version](https://img.shields.io/badge/version-1.0.0-blue.svg)
![Test Coverage](https://img.shields.io/badge/coverage-100%25-brightgreen.svg)
![License](https://img.shields.io/badge/license-MIT-green.svg)

---

## ✨ What is TSMIS Core?

**TSMIS Core Runtime** is the foundational framework for building robust, scalable, and fully modular applications in Node.js. It is designed with the principles of:

- **Dependency Injection (DI)**: Automatic resolution of component dependencies
- **Event-Driven Architecture**: Loosely coupled communication between modules
- **Health Monitoring & Metrics**: Comprehensive system observability
- **Structured Error Handling**: Standardized error types with context preservation
- **High Test Coverage (Line & Branch)**: Reliable, thoroughly tested components

TSMIS enables organizations to build large-scale systems with plug-and-play modules like CRM, HR, Scheduling, Forms, Inventory, and more. Its focus on modularity allows teams to work independently on different business domains while maintaining consistency through standardized interfaces.

---

## 🚀 Quick Start Guide

Get started with TSMIS Core in minutes:

```bash
# Install the package
npm install tsmis-core

# Create an app.js file
touch app.js
```

```javascript
// app.js
import { CoreContainer } from 'tsmis-core';
import { createErrorSystem, createEventBusSystem, createModuleSystem } from 'tsmis-core';
import { UserModule } from './modules/UserModule.js';

async function bootstrap() {
  // Create container
  const container = new CoreContainer();
  
  // Register core systems
  container.register('errorSystem', createErrorSystem);
  container.register('config', () => ({ appName: 'MyApp' }));
  container.register('eventBusSystem', createEventBusSystem);
  container.register('moduleSystem', createModuleSystem);
  
  // Initialize container
  await container.initialize();
  
  // Get module system
  const moduleSystem = await container.resolve('moduleSystem');
  
  // Register business module
  await moduleSystem.register('userModule', UserModule);
  
  // Initialize modules
  await moduleSystem.initialize();
  
  console.log('Application started successfully!');
  return container;
}

bootstrap().catch(console.error);
```

---

## 🧱 Architecture Overview

TSMIS Core is built on a layered architecture with clear separation of concerns:

```
┌─────────────────────────────────────────────────────────────┐
│                     Business Modules                         │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │ UserModule  │  │ OrderModule │  │ InventoryModule     │  │
│  └─────────────┘  └─────────────┘  └─────────────────────┘  │
├─────────────────────────────────────────────────────────────┤
│                     Module System                            │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │ ErrorSystem │  │ EventSystem │  │ Container System    │  │
│  └─────────────┘  └─────────────┘  └─────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

### Core Systems

TSMIS Core consists of the following key components:

### 1. **CoreContainer**

A sophisticated dependency injection container that handles component registration, dependency resolution, and lifecycle management:

```javascript
// Register components
container.register('database', DatabaseService);
container.register('logger', LoggerService);

// Resolve with automatic dependency injection
const database = await container.resolve('database');
```

Key features:
- Singleton and transient component support
- Automatic dependency resolution
- Lifecycle management (initialize, shutdown)
- Circular dependency detection
- Event-based component tracking

### 2. **EventBusSystem / CoreEventBus**

A powerful event bus that enables loosely coupled communication between modules:

```javascript
// Get the event bus
const eventBus = eventBusSystem.getEventBus();

// Subscribe to events
eventBus.subscribe('user.created', handleUserCreated);
eventBus.subscribe('order.*', handleAllOrderEvents);

// Emit events
await eventBus.emit('user.created', { id: 123, name: 'John Doe' });
```

Key features:
- Wildcard event listeners (`user.*`, `*.created`, `*`)
- Event history tracking for debugging
- Queued event processing for background handling
- Metrics recording and monitoring
- Health checks and status reporting

### 3. **ErrorSystem**

Standardized, namespaced error handling with contextual metadata:

```javascript
// Create specific error types
throw new ValidationError('INVALID_INPUT', 'Email is not valid', {
  field: 'email',
  value: 'invalid-email'
});

// Handle errors with context
try {
  await someOperation();
} catch (error) {
  await errorSystem.handleError(error, {
    operation: 'userRegistration',
    userId: user.id
  });
}
```

Key features:
- Specialized error types (ValidationError, AuthError, etc.)
- Error cause chaining
- Contextual error metadata
- Framework integration (Fastify, etc.)
- Environment-aware serialization

### 4. **Module & ModuleSystem**

A standardized approach to creating, managing, and connecting application components:

```javascript
// Define a module
class UserModule extends CoreModule {
  static dependencies = ['database', 'eventBusSystem'];
  
  async setupEventHandlers() {
    const eventBus = this.deps.eventBusSystem.getEventBus();
    this.subscriptions = [
      eventBus.subscribe('user.created', this.handleUserCreated.bind(this))
    ];
  }
  
  async createUser(userData) {
    const user = await this.deps.database.users.create(userData);
    await this.emit('user.created', user);
    return user;
  }
}

// Register the module
await moduleSystem.register('userModule', UserModule);
```

Key features:
- Standardized lifecycle hooks
- Automatic dependency injection
- Health monitoring
- Event-based communication
- Clean resource management

---

## 🔄 Module Communication

Business modules in TSMIS communicate primarily through events, creating a loosely coupled architecture. Here's how modules interact:

### Event-Based Communication

```javascript
// In UserModule.js
class UserModule extends CoreModule {
  // ... other code
  
  async createUser(userData) {
    // Create the user
    const user = await this.deps.database.users.create(userData);
    
    // Emit event for other modules to respond to
    await this.emit('user.created', user);
    
    return user;
  }
}

// In NotificationModule.js
class NotificationModule extends CoreModule {
  // ... other code
  
  async setupEventHandlers() {
    const eventBus = this.deps.eventBusSystem.getEventBus();
    
    // Subscribe to user.created events
    this.subscriptions = [
      eventBus.subscribe('user.created', this.sendWelcomeEmail.bind(this))
    ];
  }
  
  async sendWelcomeEmail(event) {
    const user = event.data;
    await this.emailService.send({
      to: user.email,
      subject: 'Welcome to our platform!',
      template: 'welcome-email',
      data: { user }
    });
  }
}
```

### Communication Flow Diagram

```
┌─────────────┐                 ┌─────────────────┐
│ UserModule  │                 │ NotificationModule │
└───────┬─────┘                 └─────────┬─────────┘
        │                                 │
        │ emit('user.created')           │
        │─────────────────────────┐      │
        │                         ▼      │
        │                 ┌───────────────────┐
        │                 │   EventBusSystem  │
        │                 └─────────┬─────────┘
        │                           │
        │                           │ notify subscribers
        │                           │
        │                           ▼
        │                 ┌─────────────────┐
        │                 │ sendWelcomeEmail │
        └────────────────►│    function     │
                          └─────────────────┘
```

### Advanced Pattern: Request-Response

While events are one-way communications, you can implement request-response patterns:

```javascript
// In module A: Send request and await response
async function getUserDetails(userId) {
  // Generate a unique correlation ID
  const correlationId = crypto.randomUUID();
  
  // Create a promise that will resolve when the response is received
  const responsePromise = new Promise((resolve, reject) => {
    // Set up a one-time listener for the response
    const subId = this.eventBus.subscribe(`user.details.response.${correlationId}`, (event) => {
      // Unsubscribe immediately
      this.eventBus.unsubscribe(subId);
      resolve(event.data);
    });
    
    // Set a timeout to avoid hanging
    setTimeout(() => {
      this.eventBus.unsubscribe(subId);
      reject(new Error('Request timed out'));
    }, 5000);
  });
  
  // Emit the request event
  await this.eventBus.emit('user.details.request', {
    userId,
    correlationId
  });
  
  // Wait for the response
  return responsePromise;
}

// In module B: Handle request and send response
async setupEventHandlers() {
  this.eventBus.subscribe('user.details.request', async (event) => {
    const { userId, correlationId } = event.data;
    
    try {
      // Get the requested data
      const userDetails = await this.userRepository.findById(userId);
      
      // Send the response using the correlation ID
      await this.eventBus.emit(`user.details.response.${correlationId}`, userDetails);
    } catch (error) {
      // Handle errors
      await this.handleError(error, { userId, correlationId });
    }
  });
}
```

---

## 📦 Adding Submodules to Your Application

Since TSMIS Core is designed to be an independent npm package, here's how to add and organize submodules in your application:

### Directory Structure for Business Modules

```
your-application/
├── node_modules/
│   └── tsmis-core/        # TSMIS Core as npm dependency
├── src/
│   ├── app.js             # Main application file
│   ├── config/            # Configuration files
│   └── modules/           # Business modules
│       ├── user/          # User module
│       │   ├── UserModule.js
│       │   ├── repositories/
│       │   ├── services/
│       │   └── index.js
│       ├── order/         # Order module
│       │   ├── OrderModule.js
│       │   ├── repositories/
│       │   └── index.js
│       └── notification/  # Notification module
│           ├── NotificationModule.js
│           ├── templates/
│           └── index.js
└── package.json
```

### Creating a Module

```javascript
// src/modules/user/UserModule.js
import { CoreModule } from 'tsmis-core';
import { UserRepository } from './repositories/UserRepository.js';
import { UserService } from './services/UserService.js';

export class UserModule extends CoreModule {
  static dependencies = ['errorSystem', 'eventBusSystem', 'config', 'database'];
  
  async onConfigure() {
    // Set up module-specific configuration
    this.userRepository = new UserRepository(this.deps.database);
    this.userService = new UserService(this.userRepository);
  }
  
  async setupEventHandlers() {
    const eventBus = this.deps.eventBusSystem.getEventBus();
    
    this.subscriptions = [
      eventBus.subscribe('auth.login', this.handleUserLogin.bind(this)),
      eventBus.subscribe('user.profile.updated', this.handleProfileUpdate.bind(this))
    ];
  }
  
  // Public API methods
  async createUser(userData) {
    try {
      const user = await this.userService.createUser(userData);
      await this.emit('user.created', user);
      return user;
    } catch (error) {
      await this.handleError(error, { userData });
      throw error;
    }
  }
  
  async getUserById(id) {
    return this.userRepository.findById(id);
  }
  
  // Event handlers
  async handleUserLogin(event) {
    await this.userService.updateLastLogin(event.data.userId);
  }
  
  async handleProfileUpdate(event) {
    // Handle profile updates
  }
}
```

### Module Export Pattern

```javascript
// src/modules/user/index.js
export { UserModule } from './UserModule.js';
```

### Registering Modules in Your Application

```javascript
// src/app.js
import { CoreContainer } from 'tsmis-core';
import { createErrorSystem, createEventBusSystem, createModuleSystem } from 'tsmis-core';
import { DatabaseService } from './services/DatabaseService.js';

// Import modules
import { UserModule } from './modules/user/index.js';
import { OrderModule } from './modules/order/index.js';
import { NotificationModule } from './modules/notification/index.js';

async function bootstrap() {
  // Create container
  const container = new CoreContainer();
  
  // Register core systems
  container.register('errorSystem', createErrorSystem);
  container.register('config', () => require('./config/app-config.js'));
  container.register('eventBusSystem', createEventBusSystem);
  container.register('moduleSystem', createModuleSystem);
  
  // Register services
  container.register('database', DatabaseService);
  
  // Initialize container
  await container.initialize();
  
  // Get module system
  const moduleSystem = await container.resolve('moduleSystem');
  
  // Register business modules with specific configurations
  await moduleSystem.register('userModule', UserModule, {
    userCache: { enabled: true, ttl: 3600000 }
  });
  
  await moduleSystem.register('orderModule', OrderModule, {
    orderProcessing: { batchSize: 50 }
  });
  
  await moduleSystem.register('notificationModule', NotificationModule, {
    email: { provider: 'sendgrid', apiKey: process.env.SENDGRID_API_KEY }
  });
  
  // Initialize all modules
  await moduleSystem.initialize();
  
  console.log('Application started successfully!');
  return container;
}

// Start the application
bootstrap().catch(console.error);
```

### Using Modules from Your Application Code

```javascript
// src/api/userController.js
export async function createUser(req, res, next) {
  try {
    // Get the module system
    const moduleSystem = req.app.get('moduleSystem');
    
    // Resolve the user module
    const userModule = await moduleSystem.resolve('userModule');
    
    // Use the module's functionality
    const user = await userModule.createUser(req.body);
    
    res.status(201).json(user);
  } catch (error) {
    next(error);
  }
}
```

---

## 🧰 Key Features

- ✅ **Modular & Extensible**: Add or remove capabilities without affecting other parts
- ✅ **Full Event Lifecycle**: Comprehensive event handling (emit, queue, process, history)
- ✅ **Wildcard Event Forwarding**: Subscribe with patterns like `user.*`, `*.created`, or `*`
- ✅ **Pattern-Based Subscriptions**: Flexible event subscription patterns
- ✅ **Containerized Dependencies**: Automatic dependency resolution and management
- ✅ **100% Manual Test Coverage**: Comprehensive test suite with line and branch coverage
- ✅ **Developer-Friendly Debug Logs**: Clear, contextual logging for development
- ✅ **Safe for Production**: Environment-aware behaviors and optimizations
- ✅ **Fully Pluggable Architecture**: Compose your application with interchangeable modules

---

## 📥 Installation

```bash
npm install tsmis-core
```

---

## 🛠️ How to Use TSMIS Core in Your Project

TSMIS Core is designed as a collection of independent modules that you wire together in your application. Here's how you can integrate it:

### Bootstrapping Your Application

Create an entry point for your app (for example, app.js) where you set up the core container and register both built-in and your custom modules.

```js
// app.js
import { CoreContainer } from 'tsmis-core';
import {
  createErrorSystem,
  createEventBusSystem,
  createModuleSystem
} from 'tsmis-core';

(async () => {
  // Create a new dependency injection container
  const container = new CoreContainer();

  // Register the core systems
  container.register('errorSystem', createErrorSystem);
  container.register('eventBusSystem', createEventBusSystem);
  container.register('moduleSystem', createModuleSystem);
  container.register('config', () => ({
    // Your application configuration
    appName: 'MyTSMISApp',
    environment: process.env.NODE_ENV || 'development',
    // Module-specific configurations
    userModule: {
      userCache: { enabled: true, ttl: 3600000 }
    }
  }));

  // Optionally, register your own business modules
  // container.register('myModule', require('./modules/MyModule'));

  // Initialize the container (this sets up all the core systems)
  await container.initialize();

  // Resolve systems when needed:
  const eventBusSystem = await container.resolve('eventBusSystem');
  const eventBus = eventBusSystem.getEventBus();
  const moduleSystem = await container.resolve('moduleSystem');
  const errorSystem = await container.resolve('errorSystem');

  // Example: Emit an event using the event bus
  eventBus.on('user.created', (event) => {
    console.log('New user created:', event);
  });
  await eventBus.emit('user.created', { id: 1, name: 'Alice' });

  // Example: Resolve a custom module and use it
  // const myModule = await moduleSystem.resolve('myModule');
  // myModule.doSomething();

  console.log('TSMIS Core initialized and ready to use!');
})();
```

### Using the Core Systems

#### Dependency Injection & Module Resolution:

Register and resolve modules so that dependencies are automatically injected:

```js
// MyModule.js
import { CoreModule } from 'tsmis-core';

class MyModule extends CoreModule {
  static dependencies = ['errorSystem', 'eventBusSystem', 'database'];
  
  constructor(deps) {
    super(deps);
    this.database = deps.database;
  }

  async onInitialize() {
    console.log('MyModule initialized');
  }

  async doSomething() {
    console.log('Doing something in MyModule');
    const result = await this.database.query('SELECT * FROM items');
    return result;
  }
}

export { MyModule };
```

Register and resolve the module:

```js
// In your app.js, after setting up the container:
import { MyModule } from './modules/MyModule.js';

container.register('database', DatabaseService);
container.register('myModule', MyModule);

const myModule = await container.resolve('myModule');
await myModule.doSomething();
```

#### Event-Driven Architecture:

Communicate between modules using the EventBusSystem:

```js
// Emitting an event:
const eventBus = eventBusSystem.getEventBus();
await eventBus.emit('user.created', { id: 1, name: 'Alice' });

// Subscribing to an event:
eventBus.subscribe('user.created', (event) => {
  console.log('User created event received:', event.data);
  
  // The event object includes:
  // - id: Unique identifier
  // - name: 'user.created'
  // - data: The payload ({ id: 1, name: 'Alice' })
  // - timestamp: When the event occurred
  // - metadata: Additional information
});

// Pattern-based subscriptions:
eventBus.subscribe('user.*', (event) => {
  console.log(`User event received: ${event.name}`);
});

// Wildcard subscription (all events):
eventBus.subscribe('*', (event) => {
  console.log(`Event received: ${event.name}`);
});
```

#### Error Handling:

Utilize the ErrorSystem for creating and handling errors with consistent types and detailed context:

```js
import { ValidationError } from 'tsmis-core';

try {
  // Input validation
  if (!email.includes('@')) {
    throw new ValidationError(
      'INVALID_EMAIL',
      'Email format is invalid',
      { email, field: 'email' }
    );
  }
  
  // Operation that may throw an error
  await createUser(userData);
} catch (err) {
  // Handle the error with context
  await errorSystem.handleError(err, { 
    operation: 'userRegistration',
    userData
  });
  
  // The error will be:
  // - Logged with proper context
  // - Tracked in the error system
  // - Formatted appropriately for the environment
}
```

---

## 📦 Folder Structure

```
src/
  core/
    container/        # Dependency injection container
    event/            # EventBus system
    error/            # Structured error handling
    module/           # Module and ModuleSystem logic
  app.js              # Application bootstrap
tests/
  core/
    container/        # Container tests
    event/            # EventBus tests
    error/            # Error system tests
    module/           # Module system tests
```

---

## 🧪 Testing & Coverage

TSMIS Core ships with full line and branch test coverage. To run tests:

```bash
npm test -- verbose --coverage
```

To generate coverage reports:

```bash
npx nyc --reporter=lcov --reporter=text npm test
```

You'll see detailed output like:

```
Module.js           | 100%   | 100%   | 95.83% | 100%
ModuleSystem.js     | 100%   | 100%   | 94.73% | 100%
```

### Writing Tests for Your Modules

```javascript
// tests/modules/UserModule.test.js
import { CoreModule } from 'tsmis-core';
import { UserModule } from '../../src/modules/user/UserModule.js';
import assert from 'assert';

describe('UserModule', () => {
  let userModule;
  let mockDatabase;
  let mockEventBus;
  let emittedEvents = [];
  
  beforeEach(async () => {
    // Reset tracking
    emittedEvents = [];
    
    // Create mock dependencies with plain JavaScript
    mockDatabase = {
      users: {
        create: (userData) => {
          return Promise.resolve({ id: 'user-123', name: 'Test User' });
        }
      }
    };
    
    // Track called methods
    const createSpy = mockDatabase.users.create;
    mockDatabase.users.create = (userData) => {
      mockDatabase.users.create.calls = mockDatabase.users.create.calls || [];
      mockDatabase.users.create.calls.push({ args: [userData] });
      return createSpy(userData);
    };
    
    mockEventBus = {
      subscribe: (event, handler) => {
        return 'sub-id';
      },
      emit: (eventName, data) => {
        emittedEvents.push({ eventName, data });
        return Promise.resolve(true);
      },
      unsubscribe: () => {}
    };
    
    const mockEventBusSystem = {
      getEventBus: () => mockEventBus
    };
    
    const mockErrorSystem = {
      handleError: () => Promise.resolve()
    };
    
    // Create module with dependencies
    userModule = new UserModule({
      database: mockDatabase,
      eventBusSystem: mockEventBusSystem,
      errorSystem: mockErrorSystem,
      config: {}
    });
    
    // Initialize
    await userModule.initialize();
  });
  
  test('should create a user', async () => {
    const userData = { name: 'Test User', email: 'test@example.com' };
    const result = await userModule.createUser(userData);
    
    // Verify database was called with correct data
    assert.strictEqual(mockDatabase.users.create.calls.length, 1);
    assert.deepStrictEqual(mockDatabase.users.create.calls[0].args[0], userData);
    
    // Verify event was emitted
    assert.strictEqual(emittedEvents.length, 1);
    assert.strictEqual(emittedEvents[0].eventName, 'user.created');
    assert.deepStrictEqual(emittedEvents[0].data, { 
      id: 'user-123', 
      name: 'Test User' 
    });
    
    // Verify result
    assert.deepStrictEqual(result, { id: 'user-123', name: 'Test User' });
  });
});
```

---

## 🧠 Why TSMIS?

There are many backend frameworks, but few that combine:

- **Event-first design**: Built around events rather than routes or controllers
- **DI + modularity**: True separation of concerns with automatic dependency management
- **Full health observability**: Comprehensive health monitoring at all levels
- **Wildcard and pattern event support**: Flexible event subscription patterns
- **Test-first development**: Designed with testability as a primary concern
- **Comprehensive error handling**: Structured, contextual error management

TSMIS isn't just another framework — it's a **core runtime** designed to run a suite of interdependent business systems that can evolve independently while maintaining clear interfaces.

---

## 📈 Ideal Use Cases

- **Enterprise internal platforms**: Build scalable, maintainable internal tools
- **Modular monoliths**: Create well-structured monolithic applications
- **Backend service infrastructure**: Build reliable, observable services
- **Low-code/high-productivity platforms**: Create platforms for rapid application development
- **Scalable distributed tools**: Build foundations for distributed systems
- **Multi-team projects**: Enable multiple teams to work independently on different modules

---

## 🧩 Integrations

TSMIS Core is designed to plug into any stack, but plays especially well with:

- **Fastify** for HTTP APIs
- **GraphQL** for flexible APIs
- **PostgreSQL/MySQL** for relational data
- **MongoDB** for document databases
- **Redis** for caching and pub/sub
- **NATS/RabbitMQ** for advanced messaging
- **Prometheus** for metrics
- **OpenTelemetry** for tracing

---

## 🛠️ Development Notes

- Debug logs can be toggled using `process.env.DEBUG=true`
- Stack traces are cleaned in production
- Sensitive data is excluded from public stack traces
- Set `NODE_ENV=development` for enhanced developer experience
- Set `NODE_ENV=production` for optimized performance

---

## 👥 Contributing

We welcome contributions to TSMIS Core! Here's how you can help:

### How to Contribute

1. **Fork the repository** and create your branch from `main`
2. **Install dependencies**: `npm install`
3. **Make your changes**: Implement your feature or fix
4. **Add tests**: Maintain 100% test coverage
5. **Run tests**: `npm test`
6. **Update documentation**: Keep docs in sync with code
7. **Submit a pull request**: Include a clear description of changes

### Contribution Guidelines

- Follow the existing code style and conventions
- Write clear, descriptive commit messages
- Add or update tests for all changes
- Update documentation for API changes
- Maintain backward compatibility
- Open an issue for major changes

### Code of Conduct

- Be respectful and inclusive
- Value constructive feedback
- Support a collaborative environment

---

## 📊 Versioning

TSMIS Core follows [Semantic Versioning](https://semver.org/):

- **MAJOR** version for incompatible API changes
- **MINOR** version for backward-compatible functionality
- **PATCH** version for backward-compatible bug fixes

### Version Compatibility

- We maintain compatibility within major versions
- Breaking changes are documented in release notes
- Deprecation notices are provided before removal
- LTS (Long Term Support) versions are maintained for enterprise users

---

## 📄 License

MIT License. See [LICENSE](./LICENSE).

---

## 🐂 About the Name

**TSMIS** = **Toro-SM System Management Information Stack** — the strong, test-first foundation for building anything your business needs.

---

## 💬 Contact

Built and maintained with care by [Your Name / Your Org].

Questions? Ideas? Start a discussion!

---

## 📚 Additional Resources

- [Architectural Decision Records](./docs/adr)
- [API Documentation](./docs/api)
- [Migration Guides](./docs/migrations)
- [Examples](./examples)
- [Performance Tips](./docs/performance)

---


// src/app.js

// src/app.js

import 'dotenv/config';
import Fastify from 'fastify';

// Core System Imports
import { CoreContainer } from './core/container/Container.js';
import { createErrorSystem } from './core/errors/ErrorSystem.js';
import { setupErrorHandler } from './core/errors/integrations/fastify/handler.js';
import { createModuleSystem } from './core/module/ModuleSystem.js';
import { createEventBusSystem } from './core/event/EventBusSystem.js';

export async function buildApp() {
  // Create the core container
  const container = new CoreContainer();

  // Register core systems in proper order
  container.register('errorSystem', createErrorSystem);
  container.register('config', () => ({}));
  container.register('eventBusSystem', createEventBusSystem);
  container.register('moduleSystem', createModuleSystem);

  // Create Fastify instance with error serialization
  const fastify = Fastify({
    logger: {
      level: process.env.LOG_LEVEL || 'info',
      serializers: {
        error: (error) => {
          const errorSystem = container.resolve('errorSystem');
          return errorSystem.serializeError(error);
        }
      }
    }
  });

  // Setup Fastify error handling - THIS LINE IS PRESENT
  setupErrorHandler(fastify);

  // Initialize the container
  try {
    await container.initialize();
  } catch (error) {
    console.error('Container initialization error:', error);
    throw error;
  }

  // Basic route as a health check
  fastify.get('/', async (request, reply) => {
    return { 
      status: 'ok', 
      timestamp: new Date().toISOString() 
    };
  });

  // Graceful shutdown handling
  const closeHandler = async () => {
    try {
      await fastify.close();
      await container.shutdown();
    } catch (error) {
      console.error('Shutdown error:', error);
    }
  };

  // Handle shutdown signals
  process.on('SIGINT', closeHandler);
  process.on('SIGTERM', closeHandler);
  fastify.addHook('onClose', async () => {
    await container.shutdown();
  });

  return fastify;
}


// src/core/container/Container.js

// src/core/container/Container.js

import { EventEmitter } from 'events';
import { CoreError, ConfigError, ServiceError } from '../errors/index.js';
// import { ValidationService } from '../validation/ValidationService.js';

export class CoreContainer extends EventEmitter {
  constructor() {
    super();
    this.components = new Map();
    this.instances = new Map();
    this.dependencies = new Map();
    this.manifests = new Map();
    this.initialized = false;
  }

  /**
   * Register a component manifest
   * @param {string} type - Component type
   * @param {object} manifest - Component manifest
   */
  registerManifest(type, manifest) {
    if (this.manifests.has(type)) {
      throw new ConfigError(
        'DUPLICATE_MANIFEST',
        `Manifest already registered for type: ${type}`
      );
    }
    this.manifests.set(type, manifest);
    this.emit('manifest:registered', { type, manifest });
  }

  /**
   * Register a component with the container
   * @param {string} name - Component name
   * @param {Class} Component - Component constructor
   * @param {object} options - Registration options
   */
  register(name, Component, options = {}) {
    if (this.components.has(name)) {
      throw new ConfigError(
        'DUPLICATE_COMPONENT',
        `Component ${name} is already registered`
      );
    }

    // Store component definition
    this.components.set(name, {
      Component,
      options: {
        singleton: true,
        ...options
      }
    });

    // Store dependencies
    this.dependencies.set(name, Component.dependencies || []);

    this.emit('component:registered', { name, Component });
    return this;
  }

  /**
   * Discover components in a directory
   * @param {string} type - Component type
   * @param {string} basePath - Base directory path
   */
  async discover(type, basePath) {
    if (!this.manifests.has(type)) {
      throw new ConfigError(
        'INVALID_TYPE',
        `No manifest registered for type: ${type}`
      );
    }

    try {
      const manifest = this.manifests.get(type);
      const componentPaths = await this.scanDirectory(basePath);
      const discoveredComponents = new Map();

      for (const path of componentPaths) {
        try {
          const component = await this.loadComponent(path, manifest);
          if (component) {
            discoveredComponents.set(component.name, component);
          }
        } catch (error) {
          this.emit('discovery:error', { path, error });
        }
      }

      this.emit('discovery:completed', { type, components: discoveredComponents });
      return discoveredComponents;
    } catch (error) {
      throw new ServiceError(
        'DISCOVERY_FAILED',
        `Failed to discover ${type} components`,
        { originalError: error }
      );
    }
  }

  /**
   * Load a component from a path
   * @private
   */
  async loadComponent(path, manifest) {
    try {
      const config = await this.loadConfig(path);
      if (config.enabled === false) return null;

      await this.validateConfig(config, manifest.configSchema);
      const implementation = await this.loadImplementation(path);

      return {
        name: config.name,
        config,
        implementation
      };
    } catch (error) {
      throw new ConfigError(
        'LOAD_FAILED',
        `Failed to load component from ${path}`,
        { originalError: error }
      );
    }
  }

  /**
   * Get an instance of a component
   * @param {string} name - Component name
   */
  async resolve(name) {
    if (!this.components.has(name)) {
      throw new ServiceError(
        'UNKNOWN_COMPONENT',
        `Component ${name} is not registered`
      );
    }
  
    const { Component, options } = this.components.get(name);
  
    // Return existing instance for singletons
    if (options.singleton && this.instances.has(name)) {
      return this.instances.get(name);
    }
  
    // Resolve dependencies first
    const deps = this.dependencies.get(name) || [];
    const resolvedDeps = {};
  
    for (const dep of deps) {
      resolvedDeps[dep] = await this.resolve(dep);
    }
  
    // Handle different component types
    let instance;
    if (typeof Component === 'function') {
      if (Component.prototype) {
        // Class constructor
        instance = new Component(resolvedDeps);
      } else {
        // Factory function - handle both sync and async
        instance = await Promise.resolve(Component(resolvedDeps));
      }
    } else {
      instance = Component;
    }
  
    // Initialize if container is initialized
    if (this.initialized && typeof instance.initialize === 'function') {
      await instance.initialize();
    }
  
    // Cache singleton instance
    if (options.singleton) {
      this.instances.set(name, instance);
    }
  
    this.emit('component:resolved', { name, instance });
    return instance;
  }
  /**
   * Initialize all registered components
   */
  async initialize() {
    if (this.initialized) {
      throw new ServiceError(
        'ALREADY_INITIALIZED',
        'Container is already initialized'
      );
    }
    //console.log('Initializing Container...');
    const order = this.resolveDependencyOrder();

    for (const name of order) {
      //console.log(`Resolving component: ${name}`);
      const instance = await this.resolve(name);
      if (typeof instance.initialize === 'function') {
        //console.log(`Initializing component: ${name}`);
        await instance.initialize();
      }
    }

    this.initialized = true;
    this.emit('initialized');

    
  }

  /**
   * Resolve dependency order for initialization
   * @private
   */
  resolveDependencyOrder() {
    const visited = new Set();
    const visiting = new Set();
    const order = [];

    const visit = (name) => {
      if (visited.has(name)) return;
      if (visiting.has(name)) {
        throw new ConfigError(
          'CIRCULAR_DEPENDENCY',
          `Circular dependency detected: ${name}`
        );
      }

      visiting.add(name);
      
      const component = this.components.get(name);
      const deps = this.dependencies.get(name) || [];
      
      for (const dep of deps) {
        if (!this.components.has(dep)) {
          throw new ConfigError(
            'MISSING_DEPENDENCY',
            `Dependency ${dep} required by ${name} is not registered`
          );
        }
        visit(dep);
      }
      
      visiting.delete(name);
      visited.add(name);
      order.push(name);
    };

    // Ensure core systems are initialized first
    const initOrder = [
      'errorSystem',
      'config',
      'eventBusSystem',
      'moduleSystem'
    ];

    for (const name of initOrder) {
      if (this.components.has(name)) {
        visit(name);
      }
    }

    // Then handle any remaining components
    for (const name of this.components.keys()) {
      if (!order.includes(name)) {
        visit(name);
      }
    }

    return order;
  }

async shutdown() {
    // Shutdown in reverse dependency order
    const order = this.resolveDependencyOrder().reverse();
  
    for (const name of order) {
      const instance = this.instances.get(name);
      if (instance && typeof instance.shutdown === 'function') {
        try {
          await instance.shutdown();
        } catch (error) {
          // Log error but continue shutdown process
          this.emit('shutdown:error', { 
            component: name, 
            error 
          });
        }
      }
    }
  
    this.instances.clear();
    this.initialized = false;
    this.emit('shutdown');
  }
}


// src/core/container/container-system-docs.md

# CoreContainer System Documentation

## Table of Contents
1. [Overview](#overview)
2. [Purpose](#purpose)
3. [System Architecture](#system-architecture)
4. [Core Concepts](#core-concepts)
5. [Component Registration](#component-registration)
6. [Dependency Resolution](#dependency-resolution)
7. [Lifecycle Management](#lifecycle-management)
8. [Event System Integration](#event-system-integration)
9. [Component Discovery](#component-discovery)
10. [Container Usage](#container-usage)
11. [Advanced Features](#advanced-features)
12. [Error Handling](#error-handling)
13. [Testing Strategy](#testing-strategy)
14. [Best Practices](#best-practices)
15. [Extending the System](#extending-the-system)
16. [Areas for Improvement](#areas-for-improvement)

## Overview

The CoreContainer System is a sophisticated Dependency Injection (DI) and Inversion of Control (IoC) container designed to manage component lifecycles, dependencies, and system initialization. It is responsible for managing the lifecycle and dependencies of the core systems and components in the application, including the ErrorSystem, EventBusSystem, ModuleSystem, and other registered components.

## Purpose

The primary goals of the CoreContainer System are to:
- Manage component dependencies
- Facilitate loose coupling between system components
- Automate component initialization and shutdown
- Provide a centralized component registry
- Support complex dependency graphs
- Enable predictable initialization ordering
- Facilitate testability through dependency injection

## System Architecture

### Core Components

1. **CoreContainer** (`src/core/container/Container.js`)
   - Central component management system
   - Handles component registration
   - Manages dependency resolution
   - Controls component lifecycle
   - Emits lifecycle events
   - Supports component manifests

### Architecture Diagram

```mermaid
graph TD
    A[CoreContainer] --> B[Component Registration]
    A --> C[Dependency Resolution]
    A --> D[Lifecycle Management]
    
    B --> E[Singleton/Transient Components]
    B --> F[Dependency Tracking]
    B --> G[Manifest Registration]
    
    C --> H[Topological Sorting]
    C --> I[Circular Dependency Detection]
    C --> J[Dependency Validation]
    
    D --> K[Initialization]
    D --> L[Shutdown]
    D --> M[Event Emission]
    
    N[Container Events] --> O[component:registered]
    N --> P[component:resolved]
    N --> Q[initialized]
    N --> R[shutdown]
    N --> S[discovery:error]
    N --> T[discovery:completed]
```

## Core Concepts

### Component Registration

- Components can be registered with optional configuration
- Supports singleton and transient component modes
- Tracks component dependencies
- Supports class, factory function, and instance registration

```javascript
// Class registration (singleton by default)
container.register('logger', LoggerService);

// Factory function registration
container.register('database', (deps) => {
  return createDatabaseService(deps);
});

// Direct instance registration
const configInstance = { apiKey: 'abc123' };
container.register('config', configInstance);
```

### Dependency Resolution

- Automatically resolves and injects dependencies
- Supports complex dependency graphs
- Prevents circular dependencies
- Ensures correct initialization order
- Caches singleton instances

```javascript
class AuthService {
  static dependencies = ['database', 'logger', 'config'];
  
  constructor(deps) {
    this.database = deps.database;
    this.logger = deps.logger;
    this.config = deps.config;
  }
}

container.register('auth', AuthService);
const authService = await container.resolve('auth');
```

### Lifecycle Management

- Provides `initialize()` and `shutdown()` methods
- Supports component-specific initialization logic
- Ensures proper initialization order based on dependencies
- Graceful shutdown with error handling
- Event emission for lifecycle events

```javascript
// Initialize all components in dependency order
await container.initialize();

// Graceful shutdown in reverse dependency order
await container.shutdown();
```

### Manifest Registration

- Supports component manifest registration
- Defines structure and requirements for component types
- Enables dynamic component discovery

```javascript
container.registerManifest('service', {
  configSchema: {
    /* JSON schema for service configuration */
  }
});
```

## Component Registration

The `CoreContainer.register` method is used to register components with the container:

```javascript
register(name, Component, options = {}) {
  if (this.components.has(name)) {
    throw new ConfigError(
      'DUPLICATE_COMPONENT',
      `Component ${name} is already registered`
    );
  }

  // Store component definition
  this.components.set(name, {
    Component,
    options: {
      singleton: true,
      ...options
    }
  });

  // Store dependencies
  this.dependencies.set(name, Component.dependencies || []);

  this.emit('component:registered', { name, Component });
  return this;
}
```

Components can be registered in several ways:

```javascript
// 1. Class constructor
class LoggerService {
  static dependencies = ['config'];
  constructor(deps) {
    this.config = deps.config;
  }
}
container.register('logger', LoggerService);

// 2. Factory function
const createDatabaseService = (deps) => {
  return {
    query: async () => { /* ... */ }
  };
};
container.register('database', createDatabaseService);

// 3. Direct instance (singleton)
const configValues = {
  apiUrl: 'https://api.example.com',
  timeout: 5000
};
container.register('config', configValues);
```

## Dependency Resolution

The `CoreContainer.resolve` method resolves a component and its dependencies:

```javascript
async resolve(name) {
  if (!this.components.has(name)) {
    throw new ServiceError(
      'UNKNOWN_COMPONENT',
      `Component ${name} is not registered`
    );
  }

  const { Component, options } = this.components.get(name);

  // Return existing instance for singletons
  if (options.singleton && this.instances.has(name)) {
    return this.instances.get(name);
  }

  // Resolve dependencies first
  const deps = this.dependencies.get(name) || [];
  const resolvedDeps = {};

  for (const dep of deps) {
    resolvedDeps[dep] = await this.resolve(dep);
  }

  // Handle different component types
  let instance;
  if (typeof Component === 'function') {
    if (Component.prototype) {
      // Class constructor
      instance = new Component(resolvedDeps);
    } else {
      // Factory function - handle both sync and async
      instance = await Promise.resolve(Component(resolvedDeps));
    }
  } else {
    instance = Component;
  }

  // Initialize if container is initialized
  if (this.initialized && typeof instance.initialize === 'function') {
    await instance.initialize();
  }

  // Cache singleton instance
  if (options.singleton) {
    this.instances.set(name, instance);
  }

  this.emit('component:resolved', { name, instance });
  return instance;
}
```

## Lifecycle Management

### Initialization Process

The `CoreContainer.initialize` method initializes all registered components in the correct dependency order:

```javascript
async initialize() {
  if (this.initialized) {
    throw new ServiceError(
      'ALREADY_INITIALIZED',
      'Container is already initialized'
    );
  }
  
  const order = this.resolveDependencyOrder();

  for (const name of order) {
    const instance = await this.resolve(name);
    if (typeof instance.initialize === 'function') {
      await instance.initialize();
    }
  }

  this.initialized = true;
  this.emit('initialized');
}
```

### Shutdown Process

The `CoreContainer.shutdown` method shuts down all initialized components in the reverse dependency order:

```javascript
async shutdown() {
  // Shutdown in reverse dependency order
  const order = this.resolveDependencyOrder().reverse();

  for (const name of order) {
    const instance = this.instances.get(name);
    if (instance && typeof instance.shutdown === 'function') {
      try {
        await instance.shutdown();
      } catch (error) {
        // Log error but continue shutdown process
        this.emit('shutdown:error', { 
          component: name, 
          error 
        });
      }
    }
  }

  this.instances.clear();
  this.initialized = false;
  this.emit('shutdown');
}
```

### Dependency Ordering

The `resolveDependencyOrder` method ensures components are initialized in the correct order:

```javascript
resolveDependencyOrder() {
  const visited = new Set();
  const visiting = new Set();
  const order = [];

  const visit = (name) => {
    if (visited.has(name)) return;
    if (visiting.has(name)) {
      throw new ConfigError(
        'CIRCULAR_DEPENDENCY',
        `Circular dependency detected: ${name}`
      );
    }

    visiting.add(name);
    
    const deps = this.dependencies.get(name) || [];
    
    for (const dep of deps) {
      if (!this.components.has(dep)) {
        throw new ConfigError(
          'MISSING_DEPENDENCY',
          `Dependency ${dep} required by ${name} is not registered`
        );
      }
      visit(dep);
    }
    
    visiting.delete(name);
    visited.add(name);
    order.push(name);
  };

  // Ensure core systems are initialized first
  const initOrder = [
    'errorSystem',
    'config',
    'eventBusSystem',
    'moduleSystem'
  ];

  for (const name of initOrder) {
    if (this.components.has(name)) {
      visit(name);
    }
  }

  // Then handle any remaining components
  for (const name of this.components.keys()) {
    if (!order.includes(name)) {
      visit(name);
    }
  }

  return order;
}
```

## Event System Integration

The CoreContainer integrates with the event system by emitting events at key lifecycle points:

```javascript
// Component registration
this.emit('component:registered', { name, Component });

// Component resolution
this.emit('component:resolved', { name, instance });

// Container initialization
this.emit('initialized');

// Container shutdown
this.emit('shutdown');

// Component discovery
this.emit('discovery:error', { path, error });
this.emit('discovery:completed', { type, components });

// Shutdown errors
this.emit('shutdown:error', { component: name, error });
```

You can listen for these events to monitor container activity:

```javascript
container.on('component:registered', ({ name }) => {
  console.log(`Component registered: ${name}`);
});

container.on('initialized', () => {
  console.log('Container initialized');
});
```

## Component Discovery

The CoreContainer provides mechanisms for dynamic component discovery:

```javascript
async discover(type, basePath) {
  if (!this.manifests.has(type)) {
    throw new ConfigError(
      'INVALID_TYPE',
      `No manifest registered for type: ${type}`
    );
  }

  try {
    const manifest = this.manifests.get(type);
    const componentPaths = await this.scanDirectory(basePath);
    const discoveredComponents = new Map();

    for (const path of componentPaths) {
      try {
        const component = await this.loadComponent(path, manifest);
        if (component) {
          discoveredComponents.set(component.name, component);
        }
      } catch (error) {
        this.emit('discovery:error', { path, error });
      }
    }

    this.emit('discovery:completed', { type, components: discoveredComponents });
    return discoveredComponents;
  } catch (error) {
    throw new ServiceError(
      'DISCOVERY_FAILED',
      `Failed to discover ${type} components`,
      { originalError: error }
    );
  }
}
```

## Container Usage

### Basic Usage

```javascript
import { CoreContainer } from '@core/container/Container';

// Create container
const container = new CoreContainer();

// Register components
container.register('config', { apiUrl: 'https://api.example.com' });
container.register('logger', LoggerService);
container.register('database', createDatabaseService);
container.register('authService', AuthService);

// Initialize container (all components)
await container.initialize();

// Resolve a component
const authService = await container.resolve('authService');

// Shutdown container
await container.shutdown();
```

### Application Bootstrap

```javascript
// src/app.js
import { CoreContainer } from './core/container/Container.js';
import { createErrorSystem } from './core/errors/ErrorSystem.js';
import { createEventBusSystem } from './core/event/EventBusSystem.js';
import { createModuleSystem } from './core/module/ModuleSystem.js';

export async function buildApp() {
  const container = new CoreContainer();

  // Register core systems
  container.register('errorSystem', createErrorSystem);
  container.register('config', () => ({}));
  container.register('eventBusSystem', createEventBusSystem);
  container.register('moduleSystem', createModuleSystem);

  // Initialize container
  await container.initialize();

  // Setup and return application
  const fastify = Fastify();
  // ... configure fastify
  return fastify;
}
```

## Advanced Features

### Singleton vs Transient Components

```javascript
// Singleton registration (default)
container.register('service', ServiceClass);

// Transient registration (new instance each time)
container.register('repository', RepositoryClass, { singleton: false });

// Multiple resolve calls for transient components create new instances
const repo1 = await container.resolve('repository');
const repo2 = await container.resolve('repository');
console.log(repo1 === repo2); // false

// Multiple resolve calls for singleton components return same instance
const service1 = await container.resolve('service');
const service2 = await container.resolve('service');
console.log(service1 === service2); // true
```

### Component Manifests

```javascript
// Register a component manifest
container.registerManifest('service', {
  configSchema: {
    name: { type: 'string', required: true },
    enabled: { type: 'boolean', default: true },
    options: { type: 'object' }
  }
});

// Discover components based on the manifest
const services = await container.discover('service', './services');

// Register discovered components
for (const [name, service] of services.entries()) {
  container.register(name, service.implementation, {
    config: service.config
  });
}
```

## Error Handling

### Common Error Types

- **ConfigError**: Configuration-related errors
  - `DUPLICATE_COMPONENT`: Component already registered
  - `DUPLICATE_MANIFEST`: Manifest already registered for type
  - `CIRCULAR_DEPENDENCY`: Circular dependency detected
  - `MISSING_DEPENDENCY`: Required dependency not registered
  - `INVALID_TYPE`: No manifest registered for type

- **ServiceError**: Service-level errors
  - `UNKNOWN_COMPONENT`: Component not registered
  - `ALREADY_INITIALIZED`: Container already initialized
  - `DISCOVERY_FAILED`: Failed to discover components

### Error Handling Example

```javascript
try {
  await container.initialize();
} catch (error) {
  if (error.code === 'CIRCULAR_DEPENDENCY') {
    console.error('Circular dependency detected:', error.message);
    // Fix circular dependencies
  } else if (error.code === 'MISSING_DEPENDENCY') {
    console.error('Missing dependency:', error.message);
    // Register missing dependency
  } else {
    console.error('Container initialization error:', error);
  }
}
```

## Testing Strategy

### Testing Container

```javascript
describe('CoreContainer', () => {
  let container;
  
  beforeEach(() => {
    container = new CoreContainer();
  });
  
  afterEach(async () => {
    if (container.initialized) {
      await container.shutdown();
    }
  });
  
  test('should register and resolve component', async () => {
    // Register a simple component
    container.register('testComponent', { value: 'test' });
    
    // Resolve the component
    const component = await container.resolve('testComponent');
    
    expect(component).toEqual({ value: 'test' });
  });
  
  test('should resolve dependencies', async () => {
    // Register components with dependencies
    container.register('dependency', { value: 'dependency' });
    
    class TestService {
      static dependencies = ['dependency'];
      
      constructor(deps) {
        this.dependency = deps.dependency;
      }
    }
    
    container.register('service', TestService);
    
    // Resolve component with dependencies
    const service = await container.resolve('service');
    
    expect(service.dependency).toEqual({ value: 'dependency' });
  });
  
  test('should detect circular dependencies', async () => {
    // Create circular dependency
    class ServiceA {
      static dependencies = ['serviceB'];
    }
    
    class ServiceB {
      static dependencies = ['serviceA'];
    }
    
    container.register('serviceA', ServiceA);
    container.register('serviceB', ServiceB);
    
    // Attempt to resolve should throw
    await expect(container.resolve('serviceA')).rejects.toThrow(/Circular dependency/);
  });
});
```

### Testing with Container

```javascript
describe('ServiceWithDependencies', () => {
  let container;
  let mockDatabase;
  
  beforeEach(() => {
    container = new CoreContainer();
    
    // Create mock dependencies
    mockDatabase = {
      query: jest.fn().mockResolvedValue([{ id: 1 }])
    };
    
    // Register dependencies in container
    container.register('database', mockDatabase);
    container.register('logger', { log: jest.fn() });
    
    // Register service under test
    container.register('userService', UserService);
  });
  
  test('should get users', async () => {
    // Resolve service with injected dependencies
    const userService = await container.resolve('userService');
    
    // Test service method
    const users = await userService.getUsers();
    
    // Verify expectations
    expect(users).toEqual([{ id: 1 }]);
    expect(mockDatabase.query).toHaveBeenCalledWith('SELECT * FROM users');
  });
});
```

## Best Practices

### 1. Explicit Dependencies

Always declare dependencies explicitly:

```javascript
class UserService {
  static dependencies = ['database', 'logger', 'config'];
  
  constructor(deps) {
    this.database = deps.database;
    this.logger = deps.logger;
    this.config = deps.config;
  }
}
```

### 2. Interface-Based Dependencies

Depend on interfaces rather than concrete implementations:

```javascript
// Good: Depends on interface (any object with query method)
class UserRepository {
  static dependencies = ['database'];
  
  constructor(deps) {
    this.database = deps.database;
  }
  
  async getUsers() {
    return this.database.query('SELECT * FROM users');
  }
}

// Can be used with any database implementation that has a query method
container.register('database', new PostgresDatabase());
// OR
container.register('database', new MongoDatabase());
// OR
container.register('database', new MockDatabase());
```

### 3. Lifecycle Management

Implement proper initialization and shutdown:

```javascript
class DatabaseService {
  async initialize() {
    // Set up connection pool
    this.pool = await createPool(this.config);
    return this;
  }
  
  async shutdown() {
    // Clean up resources
    await this.pool.end();
    return this;
  }
}
```

### 4. Factory Registration

Use factory functions for complex component creation:

```javascript
container.register('database', (deps) => {
  // Complex setup logic
  const pool = createPool(deps.config.database);
  const queryBuilder = createQueryBuilder();
  
  return {
    query: async (sql, params) => {
      const client = await pool.connect();
      try {
        return await client.query(sql, params);
      } finally {
        client.release();
      }
    }
  };
});
```

### 5. Testing Configuration

Create separate test configurations:

```javascript
// In tests
container.register('config', {
  database: {
    host: 'localhost',
    port: 5432,
    user: 'test',
    password: 'test'
  }
});

// In production
container.register('config', {
  database: {
    host: process.env.DB_HOST,
    port: parseInt(process.env.DB_PORT),
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD
  }
});
```

## Extending the System

### Custom Component Lifecycle

```javascript
class CustomComponent {
  async initialize() {
    // Initialize resources
    this.resource = await createResource();
    console.log('CustomComponent initialized');
    return this;
  }
  
  async shutdown() {
    // Clean up resources
    await this.resource.close();
    console.log('CustomComponent shutdown');
    return this;
  }
}
```

### Custom Manifest Validator

```javascript
container.registerManifest('service', {
  configSchema: {
    /* config schema */
  },
  
  validateComponent: async (component) => {
    // Custom validation logic
    if (!component.initialize || typeof component.initialize !== 'function') {
      throw new Error('Service must have initialize method');
    }
    return true;
  }
});
```

## Areas for Improvement

1. **Scoped Containers**:
   - Implement support for scoped containers
   - Allow creating child containers with shared or isolated component instances
   - Enable request-scoped dependencies for web applications

2. **Async Component Discovery**:
   - Improve the component discovery mechanism
   - Add support for dynamic reloading of components
   - Implement more robust directory scanning and file loading

3. **Enhanced Validation**:
   - Add schema validation for component configuration
   - Validate component interfaces against expected interfaces
   - Support TypeScript interfaces for stronger typing

4. **Lazy Initialization**:
   - Support for lazy-loaded components
   - Initialize components only when first resolved
   - Optimize startup time for large applications

5. **Dependency Visualization**:
   - Add tooling to visualize component dependency graphs
   - Detect potential architecture issues
   - Generate documentation from container structure

6. **Advanced Caching**:
   - Implement more sophisticated caching strategies
   - Support for component invalidation and reinitialization
   - Memory management for large component trees

7. **Container Events API**:
   - Enhance event system for container lifecycle
   - Add metrics and performance monitoring
   - Support for container introspection and debugging

8. **Simplified Testing**:
   - Create dedicated testing utilities
   - Easier mocking of dependencies
   - Snapshot testing for container configurations


// src/core/errors/Error.js

/**
 * Universal base error class for both client and server environments
 * @extends Error
 */
export class CoreError extends Error {
  /**
   * Create a new CoreError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(message);
    
    // Basic properties
    this.name = this.constructor.name;
    this.code = code;
    this.details = this.sanitizeDetails(details);
    this.timestamp = new Date().toISOString();

      //Debug line 29
      // console.log('Line 29 debug:', {
      //   hasOptions: options !== undefined,
      //   hasCause: options?.cause !== undefined,
      //   causeValue: options?.cause
      // });

    // Handle error cause
    this.initCause(options?.cause);
    
    // Ensure instanceof works correctly
    Object.setPrototypeOf(this, new.target.prototype);
    
    // Capture stack trace if available
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }

    // Format stack for browser environment
    if (this.isClientEnvironment()) {
      this.stack = this.formatStackTrace(this.stack);
    }
  }

  /**
   * Initialize error cause with proper error instance
   * @private
   */
  initCause(cause) {
    const ensureValidName = (error) => {
      // Reset to 'Error' if name is empty or only whitespace
      if (!error.name || !error.name.trim()) {
        error.name = 'Error';
      }
      return error;
    };
  
    if (cause instanceof Error) {
      this.cause = ensureValidName(cause);
    } else if (cause && typeof cause === 'object') {
      const error = new Error(cause.message || JSON.stringify(cause));
      if (cause.name && typeof cause.name === 'string' && cause.name.trim()) {
        error.name = cause.name;
      }
      this.cause = error;
    } else if (typeof cause === 'string') {
      this.cause = new Error(cause);
    }
  }

  /**
   * Sanitize error details for safe serialization
   * @private
   */
  sanitizeDetails(details) {
    try {
      // Test if details can be safely serialized
      JSON.stringify(details);
      return details;
    } catch (error) {
      // If serialization fails, return safe version
      return { 
        error: 'Details contained non-serializable values',
        safeDetails: String(details)
      };
    }
  }

  /**
   * Format stack trace for better readability
   * @private
   */
  formatStackTrace(stack) {
    if (!stack) return stack;
    
    return stack
      .split('\n')
      .filter(line => line.trim())
      .map(line => line.replace(/^ {4}at /, ''))
      .join('\n');
  }

  /**
   * Check if running in client environment
   * @private
   */
  isClientEnvironment() {
    return typeof window !== 'undefined';
  }

  /**
   * Check if running in development environment
   * @private
   */
  isDevEnvironment() {
    if (typeof process !== 'undefined' && process.env) {
      return process.env.NODE_ENV === 'development' || process.env.NODE_ENV === 'test';
    }
    return this.isClientEnvironment() && window.ENV === 'development';
  }

  /**
   * Convert error to JSON format
   */
  toJSON() {
    const json = {
      name: this.name,
      code: this.code,
      message: this.message,
      details: this.details,
      timestamp: this.timestamp
    };
  
    // Only include stack if it exists AND we're in dev
    if (this.isDevEnvironment() && this.stack) {
      json.stack = this.stack;
    }
  
    // Include cause if present
    if (this.cause) {
      json.cause = {
        message: this.cause.message,
        name: this.cause.name || 'Error'
      };
      
      // Only include cause stack if it exists AND we're in dev
      if (this.isDevEnvironment() && this.cause.stack) {
        json.cause.stack = this.cause.stack;
      }
    }
  
    return json;
  }

  /**
   * Create error instance from JSON data
   * @static
   */
  static fromJSON(data) {
    const options = {};
    
    if (data.cause) {
      if (typeof data.cause === 'string') {
        options.cause = data.cause;
      } else {
        options.cause = {
          message: data.cause.message,
          name: data.cause.name
        };
      }
    }

    return new this(
      data.code,
      data.message,
      data.details || {},
      options
    );
  }
}


// src/core/errors/ErrorSystem.js

// src/core/errors/ErrorSystem.js

import { EventEmitter } from 'events';
import { CoreError } from './Error.js';
import { ErrorTypes } from './types/index.js';
import { FastifyIntegration } from './integrations/fastify/FastifyIntegration.js';

export class ErrorSystem extends EventEmitter {
  static dependencies = ['logger'];

  constructor(deps = {}) {
    super();
    this.deps = deps;
    this.logger = deps.logger || console;
    this.integrations = new Map();
    this.handlers = new Map();
    this.errorTypes = new Map(Object.entries(ErrorTypes));
    this.initialized = false;

      // Ensure a default handler is always present
  this.registerHandler('*', this.defaultErrorHandler.bind(this));
  }

  async initialize() {
    if (this.initialized) {
      throw new Error('Already initialized');
    }

    // Register default handler
    this.registerHandler('*', this.defaultErrorHandler.bind(this));
    
    // Validate error types
    for (const [name, ErrorType] of this.errorTypes) {
      if (!(ErrorType.prototype instanceof CoreError)) {
        throw new CoreError('INVALID_ERROR_TYPE', `Error type ${name} must extend CoreError`);
      }
    }

    this.initialized = true;
    this.emit('initialized');
  }

  registerIntegration(framework, options = {}) {
    if (!framework) {
      throw new CoreError('INVALID_FRAMEWORK', 'Framework is required');
    }

    const integration = new FastifyIntegration();
    integration.initialize(framework, options);
    
    this.integrations.set(framework, integration);
    return integration;
  }

  registerHandler(errorType, handler) {
    if (typeof handler !== 'function') {
      throw new CoreError('INVALID_HANDLER', 'Handler must be a function');
    }
    this.handlers.set(errorType, handler);
  }

  async handleError(error, context = {}) {
    // Ensure we always have a handler
    const handler = this.handlers.get(error.constructor.name) || this.handlers.get('*') || this.defaultErrorHandler;
  
    try {
      await handler(error, context);
      this.emit('error:handled', { error, context });
    } catch (handlerError) {
      this.logger.error('Error handler failed:', handlerError);
      this.emit('error:handler:failed', { error: handlerError, originalError: error });
      throw handlerError;
    }
  }

// Ensure defaultErrorHandler is always a function
defaultErrorHandler(error, context = {}) {
  this.logger.error('Unhandled error:', {
    type: error.constructor.name,
    code: error.code,
    message: error.message,
    details: error.details,
    context
  });
}

  createError(type, code, message, details = {}, options = {}) {
    const ErrorType = this.errorTypes.get(type) || CoreError;
    return new ErrorType(code, message, details, options);
  }

  async shutdown() {
    if (!this.initialized) return;
    
    this.handlers.clear();
    this.integrations.clear();
    this.errorTypes.clear();
    this.removeAllListeners();
    this.initialized = false;
    this.emit('shutdown');
  }
}

// Factory function for container
export function createErrorSystem(deps) {
  return new ErrorSystem(deps);
}


// src/core/errors/error-system-docs.md

# Error System Documentation

## Table of Contents
1. [Overview](#overview)
2. [Purpose](#purpose)
3. [System Architecture](#system-architecture)
4. [Core Components](#core-components)
5. [Error Types](#error-types)
6. [Error Codes](#error-codes)
7. [Error Creation](#error-creation)
8. [Error Handling](#error-handling)
9. [Framework Integration](#framework-integration)
10. [Error Serialization](#error-serialization)
11. [Event System Integration](#event-system-integration)
12. [Contextual Errors](#contextual-errors)
13. [Testing Strategy](#testing-strategy)
14. [Best Practices](#best-practices)
15. [Extending the System](#extending-the-system)
16. [Areas for Improvement](#areas-for-improvement)

## Overview

The Error System is a comprehensive, extensible error handling framework designed to provide robust, consistent error management across the application. It standardizes error representation, provides detailed error context, and enables flexible error handling for improved debugging and system observability.

## Purpose

The primary goals of the Error System are to:
- Standardize error representation across the application
- Provide detailed error context for easier debugging
- Enable flexible error handling strategies
- Support comprehensive error logging and tracking
- Facilitate third-party system integration for error reporting
- Ensure proper error serialization for APIs
- Support environment-specific error formatting

## System Architecture

### High-Level Architecture

```mermaid
graph TB
    CoreError --> |Extended by| ErrorTypes
    ErrorSystem --> |Manages| ErrorTypes
    ErrorSystem --> |Registers| FrameworkIntegrations
    ErrorSystem --> |Emits| ErrorEvents
    
    ErrorTypes --> AccessError
    ErrorTypes --> AuthError
    ErrorTypes --> ConfigError
    ErrorTypes --> ModuleError
    ErrorTypes --> NetworkError
    ErrorTypes --> ServiceError
    ErrorTypes --> ValidationError
    
    FrameworkIntegrations --> FastifyIntegration
    
    FastifyIntegration --> ErrorSerializer
    FastifyIntegration --> ErrorHandler
    
    ErrorSystem --> |Handles| ErrorHandling
    ErrorHandling --> ContextEnrichment
    ErrorHandling --> Logging
    ErrorHandling --> EventEmission
```

### Core Components

The Error System consists of the following core components:

1. **CoreError** (`src/core/errors/Error.js`)
   - Base error class for all custom errors
   - Provides advanced error serialization
   - Handles error cause tracking
   - Supports environment-specific error formatting

2. **ErrorSystem** (`src/core/errors/ErrorSystem.js`)
   - Manages error types and framework integrations
   - Provides dynamic error handler registration
   - Implements event-driven error handling
   - Acts as centralized error handling service

3. **Error Types** (`src/core/errors/types/`)
   - Specialized error classes for different domains:
     * AccessError
     * AuthError
     * ConfigError
     * ModuleError
     * NetworkError
     * ServiceError
     * ValidationError

4. **Framework Integrations**
   - Framework-specific adapters for error handling:
     * FastifyIntegration

## Error Types

### CoreError

The foundation of the Error System is the `CoreError` class, which extends the native JavaScript `Error`:

```javascript
class CoreError extends Error {
  constructor(code, message, details = {}, options = {}) {
    super(message);
    
    // Basic properties
    this.name = this.constructor.name;
    this.code = code;
    this.details = this.sanitizeDetails(details);
    this.timestamp = new Date().toISOString();

    // Handle error cause
    this.initCause(options?.cause);
    
    // Ensure instanceof works correctly
    Object.setPrototypeOf(this, new.target.prototype);
    
    // Capture stack trace if available
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }

    // Format stack for browser environment
    if (this.isClientEnvironment()) {
      this.stack = this.formatStackTrace(this.stack);
    }
  }

  // Other methods...
}
```

### Specialized Error Types

The system provides several specialized error types that extend `CoreError`:

1. **AccessError** (HTTP 403)
   - Used for authorization and access control issues
   ```javascript
   throw new AccessError('FORBIDDEN', 'User does not have access to this resource');
   ```

2. **AuthError** (HTTP 401)
   - Used for authentication-related errors
   ```javascript
   throw new AuthError('INVALID_TOKEN', 'Authentication token is invalid');
   ```

3. **ConfigError** (HTTP 500)
   - Used for configuration and setup errors
   ```javascript
   throw new ConfigError('MISSING_REQUIRED', 'Required configuration value is missing');
   ```

4. **ModuleError** (HTTP 500)
   - Used for module system and initialization errors
   ```javascript
   throw new ModuleError('INITIALIZATION_FAILED', 'Failed to initialize module');
   ```

5. **NetworkError** (HTTP 503)
   - Used for network-related errors
   ```javascript
   throw new NetworkError('REQUEST_TIMEOUT', 'Network request timed out');
   ```

6. **ServiceError** (HTTP 503)
   - Used for service-level errors
   ```javascript
   throw new ServiceError('SERVICE_UNAVAILABLE', 'The requested service is unavailable');
   ```

7. **ValidationError** (HTTP 400)
   - Used for input validation errors
   ```javascript
   throw new ValidationError('INVALID_INPUT', 'Email format is invalid', {
     validationErrors: [{ field: 'email', message: 'Invalid email format' }]
   });
   ```

## Error Codes

Error codes follow a standardized structure to provide clear, hierarchical categorization:

```javascript
ErrorCodes = {
  // Core errors
  CORE: {
    UNKNOWN: 'UNKNOWN_ERROR',
    INITIALIZATION: 'INITIALIZATION_FAILED',
    VALIDATION: 'VALIDATION_FAILED'
  },

  // Module related
  MODULE: {
    INITIALIZATION: 'INITIALIZATION_FAILED',
    REGISTRATION: 'REGISTRATION_FAILED',
    DEPENDENCY: 'DEPENDENCY_ERROR',
    ROUTE: 'ROUTE_ERROR'
  },

  // Service related
  SERVICE: {
    INITIALIZATION: 'INITIALIZATION_FAILED',
    CONFIGURATION: 'CONFIGURATION_ERROR',
    DEPENDENCY: 'DEPENDENCY_ERROR',
    RUNTIME: 'RUNTIME_ERROR'
  },

  // Configuration related
  CONFIG: {
    VALIDATION: 'VALIDATION_FAILED',
    MISSING: 'MISSING_REQUIRED',
    INVALID: 'INVALID_VALUE'
  },

  // Validation related
  VALIDATION: {
    SCHEMA: 'SCHEMA_VALIDATION_FAILED',
    TYPE: 'INVALID_TYPE',
    REQUIRED: 'REQUIRED_FIELD_MISSING',
    FAILED: 'VALIDATION_FAILED'
  },

  // Network related
  NETWORK: {
    REQUEST: 'REQUEST_FAILED',
    RESPONSE: 'RESPONSE_ERROR',
    TIMEOUT: 'REQUEST_TIMEOUT',
    ROUTE_NOT_FOUND: 'ROUTE_NOT_FOUND'
  },

  // Authentication related
  AUTH: {
    UNAUTHORIZED: 'UNAUTHORIZED',
    TOKEN_EXPIRED: 'TOKEN_EXPIRED',
    INVALID_TOKEN: 'INVALID_TOKEN'
  },

  // Authorization related
  ACCESS: {
    FORBIDDEN: 'FORBIDDEN',
    INSUFFICIENT_RIGHTS: 'INSUFFICIENT_RIGHTS',
    RESOURCE_ACCESS_DENIED: 'RESOURCE_ACCESS_DENIED'
  }
};
```

## Error Creation

### Using the ErrorSystem

The `ErrorSystem` provides a factory method for creating errors:

```javascript
// Using the ErrorSystem to create errors
const error = errorSystem.createError(
  'ValidationError',
  ErrorCodes.VALIDATION.SCHEMA,
  'Request validation failed',
  {
    validationErrors: [
      { field: 'email', message: 'Email is required' }
    ]
  }
);
```

### Direct Error Creation

Errors can also be created directly:

```javascript
// Direct error creation
const error = new ValidationError(
  ErrorCodes.VALIDATION.SCHEMA,
  'Request validation failed',
  {
    validationErrors: [
      { field: 'email', message: 'Email is required' }
    ]
  }
);
```

### Error With Cause

Errors can include a cause, which helps with debugging and provides context:

```javascript
try {
  // Operation that might throw an error
  await database.connect();
} catch (originalError) {
  // Wrap the original error with additional context
  throw new ServiceError(
    ErrorCodes.SERVICE.INITIALIZATION,
    'Failed to initialize database service',
    { service: 'database' },
    { cause: originalError }
  );
}
```

## Error Handling

### Using the ErrorSystem

The `ErrorSystem` provides a centralized way to handle errors:

```javascript
// Register a handler for ValidationError
errorSystem.registerHandler('ValidationError', async (error, context) => {
  // Log validation errors with context
  logger.warn('Validation error:', {
    code: error.code,
    message: error.message,
    validationErrors: error.validationErrors,
    context
  });
  
  // Notify monitoring system
  await monitoring.recordValidationError(error, context);
});

// Handle an error
try {
  await validateUserInput(input);
} catch (error) {
  await errorSystem.handleError(error, {
    input,
    user: currentUser,
    operation: 'createUser'
  });
  
  // Rethrow or handle as needed
  throw error;
}
```

### Default Error Handler

The `ErrorSystem` includes a default error handler for unhandled error types:

```javascript
// Default error handler implementation
defaultErrorHandler(error, context = {}) {
  this.logger.error('Unhandled error:', {
    type: error.constructor.name,
    code: error.code,
    message: error.message,
    details: error.details,
    context
  });
}
```

### Error Context

Always provide context when handling errors:

```javascript
try {
  // Operation that might throw
  await userService.createUser(userData);
} catch (error) {
  // Handle with context
  await errorSystem.handleError(error, {
    userData,
    userId: currentUser.id,
    operation: 'createUser',
    timestamp: new Date().toISOString()
  });
  
  // Handle UI response
  showErrorNotification('Failed to create user');
}
```

## Framework Integration

### Fastify Integration

The Error System integrates with Fastify through the `FastifyIntegration`:

```javascript
// Setup in app.js
import { setupErrorHandler } from './core/errors/integrations/fastify/handler.js';

// Create Fastify instance with error serialization
const fastify = Fastify({
  logger: {
    level: process.env.LOG_LEVEL || 'info',
    serializers: {
      error: (error) => {
        const errorSystem = container.resolve('errorSystem');
        return errorSystem.serializeError(error);
      }
    }
  }
});

// Setup Fastify error handling
setupErrorHandler(fastify);
```

### Error Mapping

The integration maps framework-specific errors to core error types:

```javascript
// Mapping Fastify errors to core error types
mapError(error) {
  // Already our custom error
  if (error instanceof CoreError) {
    return error;
  }

  // Fastify validation errors
  if (error?.validation) {
    const validationError = new ValidationError(
      'FAILED',
      'Request validation failed',
      {
        validationErrors: error.validation
      }
    );
    validationError.statusCode = error.statusCode || 400;
    return validationError;
  }

  // Route not found
  if (error?.statusCode === 404) {
    const notFoundError = new NetworkError(
      'ROUTE_NOT_FOUND',
      `Route ${error.method || ''}:${error.url || ''} not found`
    );
    notFoundError.statusCode = 404;
    return notFoundError;
  }

  // Generic error
  const genericError = new CoreError(
    ErrorCodes.CORE.UNKNOWN,
    error?.message || 'An unexpected error occurred',
    {
      originalError: process.env.NODE_ENV === 'development' ? error : undefined
    }
  );

  genericError.statusCode = error?.statusCode || 500;
  return genericError;
}
```

### HTTP Status Codes

Error types map to appropriate HTTP status codes by default:

| Error Type | HTTP Status Code |
|------------|-----------------|
| AccessError | 403 Forbidden |
| AuthError | 401 Unauthorized |
| ConfigError | 500 Internal Server Error |
| ModuleError | 500 Internal Server Error |
| NetworkError | 503 Service Unavailable |
| ServiceError | 503 Service Unavailable |
| ValidationError | 400 Bad Request |

## Error Serialization

### JSON Serialization

Errors can be serialized to JSON using the `toJSON` method:

```javascript
// Error serialization
const error = new ValidationError(
  'INVALID_INPUT',
  'Validation failed',
  { validationErrors: [{ field: 'email', message: 'Invalid email' }] }
);

const serialized = error.toJSON();
// {
//   name: 'ValidationError',
//   code: 'VALIDATION_INVALID_INPUT',
//   message: 'Validation failed',
//   details: { validationErrors: [{ field: 'email', message: 'Invalid email' }] },
//   timestamp: '2023-07-21T12:34:56.789Z',
//   stack: '...' // Only in development environment
// }
```

### Environment-Specific Serialization

Error serialization is environment-aware:

```javascript
isDevEnvironment() {
  if (typeof process !== 'undefined' && process.env) {
    return process.env.NODE_ENV === 'development' || process.env.NODE_ENV === 'test';
  }
  return this.isClientEnvironment() && window.ENV === 'development';
}

toJSON() {
  const json = {
    name: this.name,
    code: this.code,
    message: this.message,
    details: this.details,
    timestamp: this.timestamp
  };

  // Only include stack if it exists AND we're in dev
  if (this.isDevEnvironment() && this.stack) {
    json.stack = this.stack;
  }

  // Include cause if present
  if (this.cause) {
    json.cause = {
      message: this.cause.message,
      name: this.cause.name || 'Error'
    };
    
    // Only include cause stack if it exists AND we're in dev
    if (this.isDevEnvironment() && this.cause.stack) {
      json.cause.stack = this.cause.stack;
    }
  }

  return json;
}
```

## Event System Integration

The `ErrorSystem` integrates with the event system by emitting events:

```javascript
class ErrorSystem extends EventEmitter {
  // ...other methods

  async handleError(error, context = {}) {
    // ...error handling logic

    // Emit error event
    this.emit('error:handled', { error, context });
  }

  // ...other methods
}
```

Modules and services can listen for these events:

```javascript
// Listen for error events
errorSystem.on('error:handled', ({ error, context }) => {
  // Record error in metrics, monitoring, etc.
  metrics.incrementCounter('errors', {
    type: error.constructor.name,
    code: error.code
  });
});
```

## Contextual Errors

### Adding Context to Errors

```javascript
// Add context when creating errors
const error = new ValidationError(
  ErrorCodes.VALIDATION.SCHEMA,
  'User validation failed',
  {
    validationErrors: [
      { field: 'email', message: 'Email is required' }
    ],
    userId: user.id,
    requestId: request.id
  }
);

// Add context when handling errors
try {
  await userService.updateUser(user);
} catch (error) {
  await errorSystem.handleError(error, {
    userId: user.id,
    operation: 'updateUser',
    requestId: request.id,
    timestamp: new Date().toISOString()
  });
}
```

### Error Cause Chain

```javascript
try {
  // Low-level operation
  await db.query('INSERT INTO users VALUES ($1, $2)', [user.id, user.name]);
} catch (dbError) {
  // Add database context
  const serviceError = new ServiceError(
    ErrorCodes.SERVICE.RUNTIME,
    'Database operation failed',
    { query: 'INSERT INTO users' },
    { cause: dbError }
  );
  
  try {
    // Higher-level operation
    await processUser(user);
  } catch (processError) {
    // Add process context
    throw new ModuleError(
      ErrorCodes.MODULE.RUNTIME,
      'User processing failed',
      { userId: user.id },
      { cause: processError }
    );
  }
  
  throw serviceError;
}
```

## Testing Strategy

### Testing Error Creation

```javascript
describe('CoreError', () => {
  test('should create error with minimal args', () => {
    const error = new CoreError('TEST_CODE', 'Test message');
    
    expect(error.name).toBe('CoreError');
    expect(error.code).toBe('TEST_CODE');
    expect(error.message).toBe('Test message');
    expect(error.details).toEqual({});
    expect(error.timestamp).toBeDefined();
  });
  
  test('should create error with details', () => {
    const details = { foo: 'bar' };
    const error = new CoreError('TEST_CODE', 'Test message', details);
    
    expect(error.details).toEqual(details);
  });
  
  test('should create error with cause', () => {
    const cause = new Error('Original error');
    const error = new CoreError('TEST_CODE', 'Test message', {}, { cause });
    
    expect(error.cause).toBe(cause);
  });
  
  test('should serialize to JSON', () => {
    const error = new CoreError('TEST_CODE', 'Test message');
    const json = error.toJSON();
    
    expect(json.name).toBe('CoreError');
    expect(json.code).toBe('TEST_CODE');
    expect(json.message).toBe('Test message');
  });
});
```

### Testing ErrorSystem

```javascript
describe('ErrorSystem', () => {
  let errorSystem;
  let mockLogger;
  
  beforeEach(() => {
    mockLogger = {
      error: jest.fn(),
      warn: jest.fn(),
      info: jest.fn()
    };
    
    errorSystem = new ErrorSystem({
      logger: mockLogger
    });
    
    errorSystem.initialize();
  });
  
  test('should create error with correct type', () => {
    const error = errorSystem.createError(
      'ValidationError',
      'TEST_CODE',
      'Test message'
    );
    
    expect(error).toBeInstanceOf(ValidationError);
    expect(error.code).toBe('VALIDATION_TEST_CODE');
    expect(error.message).toBe('Test message');
  });
  
  test('should handle error with registered handler', async () => {
    // Register custom handler
    const mockHandler = jest.fn();
    errorSystem.registerHandler('ValidationError', mockHandler);
    
    // Create and handle error
    const error = new ValidationError('TEST_CODE', 'Test message');
    const context = { foo: 'bar' };
    
    await errorSystem.handleError(error, context);
    
    // Verify handler was called
    expect(mockHandler).toHaveBeenCalledWith(error, context);
  });
  
  test('should fall back to default handler', async () => {
    // Create and handle error with no registered handler
    const error = new CoreError('TEST_CODE', 'Test message');
    const context = { foo: 'bar' };
    
    await errorSystem.handleError(error, context);
    
    // Verify default handler behavior (logger called)
    expect(mockLogger.error).toHaveBeenCalled();
  });
});
```

### Testing Error Integration

```javascript
describe('FastifyIntegration', () => {
  let fastify;
  let integration;
  
  beforeEach(async () => {
    // Create Fastify instance
    fastify = Fastify();
    
    // Create and initialize integration
    integration = new FastifyIntegration();
    await integration.initialize(fastify);
    
    // Register test route
    fastify.get('/test', () => {
      throw new ValidationError('TEST', 'Test error');
    });
    
    await fastify.ready();
  });
  
  afterEach(async () => {
    await fastify.close();
  });
  
  test('should handle custom errors', async () => {
    const response = await fastify.inject({
      method: 'GET',
      url: '/test'
    });
    
    expect(response.statusCode).toBe(400); // ValidationError status code
    
    const payload = JSON.parse(response.payload);
    expect(payload.code).toBe('VALIDATION_TEST');
    expect(payload.message).toBe('Test error');
  });
  
  test('should map framework errors', async () => {
    const response = await fastify.inject({
      method: 'GET',
      url: '/not-found'
    });
    
    expect(response.statusCode).toBe(404);
    
    const payload = JSON.parse(response.payload);
    expect(payload.code).toBe('NETWORK_ROUTE_NOT_FOUND');
  });
});
```

## Best Practices

### 1. Use Specific Error Types

Always use the most specific error type for the situation:

```javascript
// Bad - generic error
throw new Error('User not found');

// Good - specific error type
throw new ServiceError(
  ErrorCodes.SERVICE.NOT_FOUND,
  'User not found',
  { userId }
);
```

### 2. Provide Detailed Context

Include relevant context in error details:

```javascript
// Bad - minimal context
throw new ValidationError(
  ErrorCodes.VALIDATION.FAILED,
  'Validation failed'
);

// Good - detailed context
throw new ValidationError(
  ErrorCodes.VALIDATION.FAILED,
  'User validation failed',
  {
    validationErrors: [
      { field: 'email', message: 'Email is required' },
      { field: 'password', message: 'Password must be at least 8 characters' }
    ],
    userId,
    requestId,
    timestamp: new Date().toISOString()
  }
);
```

### 3. Use Error Cause for Nested Errors

Preserve the error chain with `cause`:

```javascript
try {
  await userRepository.save(user);
} catch (dbError) {
  // Wrap with higher-level context
  throw new ServiceError(
    ErrorCodes.SERVICE.RUNTIME,
    'Failed to save user',
    { userId: user.id },
    { cause: dbError }
  );
}
```

### 4. Centralize Error Handling

Use the `ErrorSystem` for centralized handling:

```javascript
try {
  await operation();
} catch (error) {
  // Let the ErrorSystem handle it
  await errorSystem.handleError(error, context);
  
  // Then decide whether to rethrow, return, etc.
  return { success: false, error: error.message };
}
```

### 5. Environment-Aware Error Responses

Be careful about exposing sensitive information:

```javascript
// In controller/API layer
try {
  const result = await userService.createUser(userData);
  return { success: true, user: result };
} catch (error) {
  // Log the full error with context
  await errorSystem.handleError(error, { userData, operation: 'createUser' });
  
  // Return sanitized error to client
  return {
    success: false,
    error: {
      code: error.code,
      message: error.message,
      // Only include safe details
      validationErrors: error.validationErrors
    }
  };
}
```

## Extending the System

### Custom Error Types

Create custom error types for domain-specific errors:

```javascript
import { CoreError } from '@core/errors/Error';

class PaymentError extends CoreError {
  constructor(code, message, details = {}, options = {}) {
    // Prefix code with domain
    super(`PAYMENT_${code}`, message, details, options);
    
    // Set default status code
    this.statusCode = 402; // Payment Required
  }
}

// Usage
throw new PaymentError(
  'INSUFFICIENT_FUNDS',
  'Insufficient funds to complete transaction',
  { accountId, required: 100, available: 50 }
);
```

### Custom Error Handlers

Register custom handlers for specific error types:

```javascript
// Register handler for PaymentError
errorSystem.registerHandler('PaymentError', async (error, context) => {
  // Log payment errors
  logger.warn('Payment error:', {
    code: error.code,
    message: error.message,
    details: error.details,
    context
  });
  
  // Notify payment service
  await paymentService.notifyErrorMonitoring(error, context);
  
  // Update metrics
  metrics.incrementCounter('payment.errors', {
    code: error.code
  });
});
```

### Framework Integration

Create custom framework integrations:

```javascript
import { IFrameworkIntegration } from '@core/errors/integrations/IFrameworkIntegration';

class ExpressIntegration extends IFrameworkIntegration {
  async initialize(app, options = {}) {
    // Register error middleware
    app.use((error, req, res, next) => {
      // Map to core error
      const mappedError = this.mapError(error);
      
      // Serialize error
      const serialized = this.serializeError(mappedError, {
        url: req.url,
        method: req.method,
        requestId: req.id
      });
      
      // Send response
      res.status(mappedError.statusCode || 500).json(serialized);
    });
  }
  
  mapError(error) {
    // Mapping logic
  }
  
  serializeError(error, context) {
    // Serialization logic
  }
}
```

## Areas for Improvement

1. **Enhanced Error Tracking**:
   - Implement error aggregation and deduplication
   - Add unique error identifiers for tracing through the system
   - Support correlation IDs for distributed tracing
   - Add timestamps for error lifecycle events

2. **Advanced Framework Integrations**:
   - Complete the `IntegrationRegistry` implementation
   - Add support for more frameworks (Express, Koa, etc.)
   - Create client-side error handling integration
   - Support GraphQL error formatting

3. **Error Reporting Services**:
   - Add integration with third-party error reporting services
   - Support for Sentry, Rollbar, New Relic, etc.
   - Batch error reporting for high-volume systems
   - Controlled sampling for production environments

4. **Performance Optimization**:
   - Optimize error serialization for high-throughput APIs
   - Implement error rate limiting to prevent cascading failures
   - Add intelligent error suppression for noisy errors
   - Benchmark and optimize error creation performance

5. **Error Analysis Tools**:
   - Create tools for analyzing error patterns
   - Implement error categorization and prioritization
   - Add support for automated root cause analysis
   - Develop visualization for error trends and distributions

6. **Security Enhancements**:
   - Improve sanitization of sensitive data in error details
   - Add configurable redaction policies for error fields
   - Implement security scanning for error messages
   - Add protection against error message information leakage

7. **Developer Experience**:
   - Create better error debugging tools and helpers
   - Add code location and context to error objects
   - Implement contextual help for common errors
   - Add links to documentation for error resolution

8. **Testing Improvements**:
   - Create more comprehensive testing utilities
   - Add error simulation capabilities for testing
   - Implement automated error scenario testing
   - Develop tools for testing error handling consistency


// src/core/errors/index.js

// src/core/errors/index.js

import { CoreError } from "./Error.js";
import {
  ErrorTypes as TypedErrors,
  AccessError,
  AuthError,
  ConfigError,
  EventError,
  ModuleError,
  NetworkError,
  ServiceError,
  ValidationError,
} from "./types/index.js";

// Create complete ErrorTypes including CoreError
export const ErrorTypes = {
  CoreError,
  ...TypedErrors,
};

// Export individual error classes
export {
  CoreError,
  AccessError,
  AuthError,
  ConfigError,
  EventError,
  ModuleError,
  NetworkError,
  ServiceError,
  ValidationError,
};

/**
 * Standard error codes
 */
export const ErrorCodes = {
  // Core errors
  CORE: {
    UNKNOWN: "UNKNOWN_ERROR",
    INITIALIZATION: "INITIALIZATION_FAILED",
    VALIDATION: "VALIDATION_FAILED",
  },

  // Module related
  MODULE: {
    INITIALIZATION: "INITIALIZATION_FAILED",
    REGISTRATION: "REGISTRATION_FAILED",
    DEPENDENCY: "DEPENDENCY_ERROR",
    ROUTE: "ROUTE_ERROR",
  },

  // Event related
  EVENT: {
    INITIALIZATION: "INITIALIZATION_FAILED",
    EMISSION_FAILED: "EMISSION_FAILED",
    SUBSCRIPTION_FAILED: "SUBSCRIPTION_FAILED",
    INVALID_PATTERN: "INVALID_PATTERN",
    INVALID_EVENT_NAME: "INVALID_EVENT_NAME",
    QUEUE_PROCESSING_FAILED: "QUEUE_PROCESSING_FAILED",
    HANDLER_NOT_FOUND: "HANDLER_NOT_FOUND",
    INVALID_HANDLER:"INVALID_HANDLER",
    SHUTDOWN_FAILED:"SHUTDOWN_FAILED",
    HANDLER_ERROR: "HANDLER_ERROR",
    MISSING_DEPENDENCIES:"MISSING_DEPENDENCIES",
    INVALID_DEPENDENCY:"INVALID_DEPENDENCY",
    NOT_INITIALIZED:"NOT_INITIALIZED"
  },

  // Service related
  SERVICE: {
    INITIALIZATION: "INITIALIZATION_FAILED",
    CONFIGURATION: "CONFIGURATION_ERROR",
    DEPENDENCY: "DEPENDENCY_ERROR",
    RUNTIME: "RUNTIME_ERROR",
  },

  // Configuration related
  CONFIG: {
    VALIDATION: "VALIDATION_FAILED",
    MISSING: "MISSING_REQUIRED",
    INVALID: "INVALID_VALUE",
  },

  // Validation related
  VALIDATION: {
    SCHEMA: "SCHEMA_VALIDATION_FAILED",
    TYPE: "INVALID_TYPE",
    REQUIRED: "REQUIRED_FIELD_MISSING",
    FAILED: "VALIDATION_FAILED", // Added for validation errors
  },

  // Network related
  NETWORK: {
    REQUEST: "REQUEST_FAILED",
    RESPONSE: "RESPONSE_ERROR",
    TIMEOUT: "REQUEST_TIMEOUT",
    ROUTE_NOT_FOUND: "ROUTE_NOT_FOUND", // Added for 404 errors
  },

  // Authentication related
  AUTH: {
    UNAUTHORIZED: "UNAUTHORIZED",
    TOKEN_EXPIRED: "TOKEN_EXPIRED",
    INVALID_TOKEN: "INVALID_TOKEN",
  },

  // Authorization related
  ACCESS: {
    FORBIDDEN: "FORBIDDEN",
    INSUFFICIENT_RIGHTS: "INSUFFICIENT_RIGHTS",
    RESOURCE_ACCESS_DENIED: "RESOURCE_ACCESS_DENIED",
  },
};

export function createErrorFromResponse(
  response,
  defaultMessage = "Unknown error occurred"
) {
  const errorData = response.data || response;

  // Map error names to constructors from ErrorTypes
  const ErrorConstructor = ErrorTypes[errorData.name] || CoreError;

  return new ErrorConstructor(
    errorData.code || ErrorCodes.CORE.UNKNOWN,
    errorData.message || defaultMessage,
    errorData.details || {},
    { cause: response }
  );
}

export default ErrorTypes;


// src/core/errors/integrations/IFrameworkIntegration.js

// src/core/errors/integrations/IFrameworkIntegration.js

/**
 * Interface for framework error integration
 * @interface
 */
export class IFrameworkIntegration {
  /**
   * Initialize error handling for framework
   * @param {any} framework - Framework instance
   * @param {Object} options - Integration options
   */
  initialize(framework, options = {}) {
    throw new Error('initialize() must be implemented');
  }

  /**
   * Serialize error for framework response
   * @param {Error} error - Error to serialize
   * @returns {Object} Serialized error
   */
  serializeError(error) {
    throw new Error('serializeError() must be implemented');
  }

  /**
   * Map framework error to core error
   * @param {Error} frameworkError - Framework-specific error
   * @returns {CoreError} Mapped core error
   */
  mapError(frameworkError) {
    throw new Error('mapError() must be implemented');
  }
}


// src/core/errors/integrations/fastify/FastifyIntegration.js

// src/core/errors/integrations/fastify/FastifyIntegration.js

import { IFrameworkIntegration } from '../IFrameworkIntegration.js';
import { CoreError, ErrorCodes } from '../../index.js';
import { ValidationError, NetworkError } from '../../types/index.js';

export class FastifyIntegration extends IFrameworkIntegration {
  constructor() {
    super();
    this.initialized = false;
  }

  async initialize(fastify, options = {}) {
    if (this.initialized) {
      return;
    }

    // Add error context to request
    fastify.addHook('onRequest', async (request) => {
      if (!request) {
        return;
      }
      
      request.errorContext = {
        url: request?.url || '',
        method: request?.method || '',
        id: request?.id
      };
    });

    // Set error handler
    fastify.setErrorHandler(async (error, request, reply) => {
      const errorContext = {
        requestId: request?.id,
        timestamp: new Date().toISOString(),
        url: request?.url || '',
        method: request?.method || ''
      };

      const mappedError = this.mapError(error);
      const serializedError = this.serializeError(mappedError, errorContext);

      reply.status(mappedError.statusCode || 500);
      return reply.send(serializedError);
    });

    this.initialized = true;
  }

  mapError(error) {
    // Already our custom error
    if (error instanceof CoreError) {
      return error;
    }

    // Fastify validation errors
    // TODO: Need a network error
    if (error?.validation) {
      const validationError = new ValidationError(
        'FAILED',
        'Request validation failed',
        {
          validationErrors: error.validation
        }
      );
      validationError.statusCode = error.statusCode || 400;
      return validationError;
    }

    // Route not found
    if (error?.statusCode === 404) {
      const notFoundError = new NetworkError(
        'ROUTE_NOT_FOUND',
        `Route ${error.method || ''}:${error.url || ''} not found`
      );
      notFoundError.statusCode = 404;
      return notFoundError;
    }

    // Generic error
    const genericError = new CoreError(
      ErrorCodes.CORE.UNKNOWN,
      error?.message || 'An unexpected error occurred',
      {
        originalError: process.env.NODE_ENV === 'development' ? error : undefined
      }
    );

    genericError.statusCode = error?.statusCode || 500;
    return genericError;
  }

  serializeError(error, context = {}) {
    const safeContext = context || {};

    if (error instanceof CoreError) {
      const serialized = error.toJSON();
      return {
        ...serialized,
        context: safeContext
      };
    }

    return {
      code: ErrorCodes.CORE.UNKNOWN,
      message: error?.message || 'Unknown error occurred',
      timestamp: new Date().toISOString(),
      context: safeContext
    };
  }
}


// src/core/errors/integrations/fastify/handler.js

// src/core/errors/integrations/fastify/handler.js

import { IFrameworkIntegration } from '../IFrameworkIntegration.js';
import { CoreError, ErrorCodes } from '../../index.js';
import { ValidationError, NetworkError } from '../../types/index.js';

class FastifyErrorHandler extends IFrameworkIntegration {
  constructor() {
    super();
    this.initialized = false;
  }

  initialize(fastify, options = {}) {
    if (this.initialized) {
      return this;
    }

    if (!fastify || typeof fastify.addHook !== 'function') {
      throw new Error('Invalid fastify instance');
    }

    fastify.addHook('onRequest', async (request) => {
      if (!request) return;

      request.errorContext = {
        url: request?.url || '',
        method: request?.method || '',
        id: request?.id
      };
    });

    fastify.setErrorHandler(async (error, request, reply) => {
      if (!reply || typeof reply.status !== 'function') {
        throw new Error('Invalid reply object');
      }

      const errorContext = {
        requestId: request?.id,
        timestamp: new Date().toISOString(),
        url: request?.url || '',
        method: request?.method || ''
      };

      const mappedError = this.mapError(error);
      const serializedError = this.serializeError(mappedError, errorContext);

      reply.status(mappedError.statusCode || 500);
      return reply.send(serializedError);
    });

    this.initialized = true;
    return this;
  }

  mapError(error) {
    if (error instanceof CoreError) {
      return error;
    }

    if (error?.validation) {
      const validationError = new ValidationError(
        'FAILED',
        'Request validation failed',
        {
          validationErrors: error.validation
        }
      );
      validationError.statusCode = error.statusCode || 400;
      return validationError;
    }

    if (error?.statusCode === 404) {
      const notFoundError = new NetworkError(
        'ROUTE_NOT_FOUND',
        `Route ${error.method || ''}:${error.url || ''} not found`
      );
      notFoundError.statusCode = 404;
      return notFoundError;
    }

    const genericError = new CoreError(
      ErrorCodes.CORE.UNKNOWN,
      error?.message || 'An unexpected error occurred',
      {
        originalError: process.env.NODE_ENV === 'development' ? error : undefined
      }
    );

    genericError.statusCode = error?.statusCode || 500;
    return genericError;
  }

  serializeError(error, context = {}) {
    const safeContext = context || {};

    if (error instanceof CoreError) {
      const serialized = error.toJSON();
      return {
        ...serialized,
        context: safeContext
      };
    }

    return {
      code: ErrorCodes.CORE.UNKNOWN,
      message: error?.message || 'Unknown error occurred',
      timestamp: new Date().toISOString(),
      context: safeContext
    };
  }
}

// Create singleton instance
const fastifyErrorHandler = new FastifyErrorHandler();

export function setupErrorHandler(fastify, options = {}) {
  return fastifyErrorHandler.initialize(fastify, options);
}

export { fastifyErrorHandler, FastifyErrorHandler };


// src/core/errors/integrations/fastify/index.js

export { setupErrorHandler } from './handler.js';
export { errorSerializer } from './serializer.js';


// src/core/errors/integrations/fastify/serializer.js

import { fastifyErrorHandler } from './handler.js';

export const errorSerializer = {
  serializer: (error) => fastifyErrorHandler.serializeError(error)
};


// src/core/errors/types/AccessError.js

import { CoreError } from '../Error.js';

/**
 * Authorization and access control related errors
 * @extends CoreError
 */
export class AccessError extends CoreError {
  /**
   * Create a new AccessError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`ACCESS_${code}`, message, details, options);
    this.statusCode = 403;
  }
}


// src/core/errors/types/AuthError.js

import { CoreError } from '../Error.js';

/**
 * Authentication related errors
 * @extends CoreError
 */
export class AuthError extends CoreError {
  /**
   * Create a new AuthError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`AUTH_${code}`, message, details, options);
    this.statusCode = 401;
  }
}


// src/core/errors/types/ConfigError.js

import { CoreError } from '../Error.js';

/**
 * Configuration related errors
 * @extends CoreError
 */
export class ConfigError extends CoreError {
  /**
   * Create a new ConfigError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`CONFIG_${code}`, message, details, options);
    this.statusCode = 500;
  }
}


// src/core/errors/types/EventError.js

// src/core/errors/types/EventError.js

import { CoreError } from '../Error.js';

/**
 * Event system related errors
 * @extends CoreError
 */
export class EventError extends CoreError {
  /**
   * Create a new EventError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`EVENT_${code}`, message, details, options);
    this.statusCode = 500;
  }
}


// src/core/errors/types/ModuleError.js

import { CoreError } from '../Error.js';

/**
 * Module system related errors
 * @extends CoreError
 */
export class ModuleError extends CoreError {
  /**
   * Create a new ModuleError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`MODULE_${code}`, message, details, options);
    this.statusCode = 500;
  }
}


// src/core/errors/types/NetworkError.js

import { CoreError } from '../Error.js';

/**
 * Network related errors
 * @extends CoreError
 */
export class NetworkError extends CoreError {
  /**
   * Create a new NetworkError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`NETWORK_${code}`, message, details, options);
    // Use provided status code or default to 503
    this.statusCode = details.statusCode || 503;
  }
}


// src/core/errors/types/ServiceError.js

import { CoreError } from '../Error.js';

/**
 * Service related errors
 * @extends CoreError
 */
export class ServiceError extends CoreError {
  /**
   * Create a new ServiceError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`SERVICE_${code}`, message, details, options);
    this.statusCode = 503;
  }
}


// src/core/errors/types/ValidationError.js

import { CoreError } from '../Error.js';

/**
 * Validation related errors
 * @extends CoreError
 */
export class ValidationError extends CoreError {
  /**
   * Create a new ValidationError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details with validation errors
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`VALIDATION_${code}`, message, details, options);
    this.statusCode = 400;
    this.validationErrors = this.validationErrors = Array.isArray(details.validationErrors) ? details.validationErrors : [];
  }

  /**
   * Convert to JSON format with validation errors
   */
  toJSON() {
    const json = super.toJSON();
    json.validationErrors = this.validationErrors;
    return json;
  }

  /**
   * Create from JSON with validation errors
   * @param {Object} data - JSON data
   */
  static fromJSON(data) {
    const error = super.fromJSON(data);
    error.validationErrors = Array.isArray(data.validationErrors) ? data.validationErrors : [];
    return error;
  }
}


// src/core/errors/types/index.js

// src/core/errors/types/index.js

import { AccessError } from './AccessError.js';
import { AuthError } from './AuthError.js';
import { ConfigError } from './ConfigError.js';
import { EventError } from './EventError.js';
import { ModuleError } from './ModuleError.js';
import { NetworkError } from './NetworkError.js';
import { ServiceError } from './ServiceError.js';
import { ValidationError } from './ValidationError.js';

// Export individual error types
export {
    AccessError,
    AuthError,
    ConfigError,
    EventError,
    ModuleError,
    NetworkError,
    ServiceError,
    ValidationError
};

// Create the ErrorTypes namespace
const ErrorTypes = {
    AccessError,
    AuthError,
    ConfigError,
    EventError,
    ModuleError,
    NetworkError,
    ServiceError,
    ValidationError
};

// Export ErrorTypes as both named and default export
export { ErrorTypes };
export default ErrorTypes;


// src/core/event/EventBus.js

// src/core/event/EventBus.js

import { EventEmitter } from "events";
import { CoreError, EventError, ErrorCodes } from "../errors/index.js";

export class CoreEventBus extends EventEmitter {
  static dependencies = ["errorSystem", "config"];
  static version = "1.0.0";

  constructor(deps = {}) {
    super();
    this.deps = deps;
    this.queues = new Map();
    this.subscriptions = new Map();
    this.history = new Map();
    this.maxHistorySize = deps.config?.eventHistory?.maxSize || 1000;
    this.initialized = false;

    // Enhanced state tracking
    this.state = {
      status: "created",
      startTime: null,
      metrics: new Map(),
      errors: [],
      healthChecks: new Map(),
    };

    // Set up health check function map
    this.setupDefaultHealthChecks();
  }

  /**
   * Set up default health checks
   * @private
   */
  setupDefaultHealthChecks() {
    // Register default health check for state
    this.registerHealthCheck("state", async () => {
      return {
        status: this.initialized ? "healthy" : "unhealthy",
        uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
        errorCount: this.state.errors.length,
      };
    });

    // Register health check for event queues
    this.registerHealthCheck("queues", async () => {
      const queueCounts = {};
      let totalQueuedEvents = 0;

      this.queues.forEach((queue, key) => {
        queueCounts[key] = queue.length;
        totalQueuedEvents += queue.length;
      });

      return {
        status: "healthy",
        queueCount: this.queues.size,
        totalQueuedEvents,
        queues: queueCounts,
      };
    });

    // Register health check for subscriptions
    this.registerHealthCheck("subscriptions", async () => {
      return {
        status: "healthy",
        count: this.subscriptions.size,
        patterns: Array.from(this.subscriptions.values()).map((s) => s.pattern),
      };
    });
  }

  /**
   * Register a health check function
   * @param {string} name - Health check name
   * @param {Function} checkFn - Health check function
   */
  registerHealthCheck(name, checkFn) {
    if (typeof checkFn !== "function") {
      throw new EventError(
        ErrorCodes.EVENT.INVALID_HANDLER,
        `Health check ${name} must be a function`,
        { checkName: name }
      );
    }
    this.state.healthChecks.set(name, checkFn);
  }

  /**
   * Perform health checks
   * @returns {Object} Health check results
   */
  async checkHealth() {
    const results = {};
    let overallStatus = "healthy";

    for (const [name, checkFn] of this.state.healthChecks) {
      try {
        results[name] = await checkFn();
        if (results[name].status !== "healthy") {
          overallStatus = "unhealthy";
        }
      } catch (error) {
        results[name] = {
          status: "error",
          error: error.message,
        };
        overallStatus = "unhealthy";
      }
    }

    return {
      name: "CoreEventBus",
      version: CoreEventBus.version,
      status: overallStatus,
      timestamp: new Date().toISOString(),
      checks: results,
    };
  }

  /**
   * Record a metric
   * @param {string} name - Metric name
   * @param {*} value - Metric value
   * @param {Object} tags - Metric tags
   */
  recordMetric(name, value, tags = {}) {
    this.state.metrics.set(name, {
      value,
      timestamp: Date.now(),
      tags,
    });
  }

  /**
   * Set up wildcard event forwarding
   * @private
   */
  setupWildcardForwarding() {
    // Only set up once
    if (this._originalEmit) return;

    // Store original emit
    this._originalEmit = this.emit;

    // Create new emit function with wildcard forwarding
    this.emit = function (eventName, data, options = {}) {
      // Call original emit for regular event
      const result = this._originalEmit.call(this, eventName, data, options);

      // Forward to wildcard handlers with correct parameters
      if (eventName !== "*") {
        this._originalEmit.call(this, "*", eventName, data);
      }

      return result;
    }.bind(this);

    // Log and record metric
    //console.log('Wildcard event forwarding enabled');
    this.recordMetric("eventbus.wildcard.enabled", 1);

    return true;
  }

  /**
   * Remove wildcard event forwarding
   * @private
   */
  removeWildcardForwarding() {
    if (!this._originalEmit) return;

    // Restore original emit
    this.emit = this._originalEmit;
    this._originalEmit = null;

    // Log and record metric
    //console.log('Wildcard event forwarding disabled');
    this.recordMetric("eventbus.wildcard.disabled", 1);

    return true;
  }

  async initialize() {
    if (this.initialized) {
      throw new EventError(
        ErrorCodes.EVENT.INITIALIZATION_FAILED,
        "EventBus is already initialized",
        { state: this.state.status }
      );
    }

    try {
      // Initialize event tracking
      this.state.status = "initializing";
      this.state.startTime = Date.now();

      // Set up newListener handler for wildcard support
      this.on("newListener", (event, listener) => {
        // Guard against recursion
        if (this._processingNewListener) return;
        this._processingNewListener = true;

        try {
          // Handle event being an object or string
          const eventName =
            typeof event === "string"
              ? event
              : event && event.toString
              ? event.toString()
              : String(event);

          // Set up wildcard forwarding when first '*' listener is added
          if (eventName === "*") {
            this.setupWildcardForwarding();
          }
        } finally {
          this._processingNewListener = false;
        }
      });

      // Clean up wildcard support when all "*" listeners are removed
      this.on("removeListener", (event) => {
        if (event === "*" && this.listenerCount("*") === 0) {
          this.removeWildcardForwarding();
        }
      });

      this.initialized = true;
      this.state.status = "running";
      this.emit("system:initialized", {
        timestamp: new Date().toISOString(),
      });

      this.recordMetric("eventbus.initialized", 1);
    } catch (error) {
      this.state.status = "error";
      this.state.errors.push({
        timestamp: new Date().toISOString(),
        error: error.message,
      });
      await this.handleError(error);

      throw new EventError(
        ErrorCodes.EVENT.INITIALIZATION,
        "Failed to initialize EventBus",
        { originalError: error.message },
        { cause: error }
      );
    }
  }

  /**
   * Handle errors with proper context
   * @param {Error} error - Error object
   * @param {Object} context - Error context
   * @returns {Promise<void>}
   */
  async handleError(error, context = {}) {
    // Add error to state
    this.state.errors.push({
      timestamp: new Date().toISOString(),
      error: error.message,
      context: context || {},
    });

    // Trim error history if needed
    if (this.state.errors.length > 100) {
      this.state.errors.shift();
    }

    // Record metric
    this.recordMetric("eventbus.errors", 1, {
      errorType: error.constructor.name,
      errorCode: error.code,
    });

    // Forward to error system if available
    if (this.deps.errorSystem) {
      await this.deps.errorSystem.handleError(error, {
        source: "CoreEventBus",
        ...context,
      });
    }
  }

  /**
   * Enhanced emit with queuing, history, and pattern matching
   * @param {string} eventName - Event name
   * @param {*} data - Event data
   * @param {Object} options - Emission options
   * @returns {boolean} - Whether the event had listeners
   */
  async emit(eventName, data, options = {}) {
    try {
      if (!eventName || typeof eventName !== "string") {
        throw new EventError(
          ErrorCodes.EVENT.INVALID_EVENT_NAME,
          "Event name must be a non-empty string",
          { providedEventName: eventName }
        );
      }

      const event = {
        id: crypto.randomUUID(),
        name: eventName,
        data,
        timestamp: new Date().toISOString(),
        metadata: options.metadata || {},
      };

      // Store in history
      this.trackEvent(event);

      // Record metric
      this.recordMetric("eventbus.events.emitted", 1, {
        eventName,
        queued: Boolean(options.queue),
      });

      // Handle queuing if needed
      if (options.queue) {
        return this.queueEvent(event, options);
      }

      // Normal event emission
      return super.emit(eventName, event);
    } catch (error) {
      await this.handleError(error, {
        eventName,
        data,
        options,
      });

      // Wrap original error
      if (!(error instanceof EventError)) {
        throw new EventError(
          ErrorCodes.EVENT.EMISSION_FAILED,
          `Failed to emit event: ${eventName}`,
          { eventName, options },
          { cause: error }
        );
      }

      throw error;
    }
  }

  /**
   * Enhanced subscription with pattern matching support
   * @param {string} pattern - Event pattern (supports * wildcard)
   * @param {Function} handler - Event handler
   * @param {Object} options - Subscription options
   * @returns {string} - Subscription ID
   */
  subscribe(pattern, handler, options = {}) {
    try {
      // Validate pattern
      if (!pattern || typeof pattern !== "string") {
        throw new EventError(
          ErrorCodes.EVENT.INVALID_PATTERN,
          "Event pattern must be a non-empty string",
          { providedPattern: pattern }
        );
      }

      // Validate handler
      if (typeof handler !== "function") {
        throw new EventError(
          ErrorCodes.EVENT.INVALID_HANDLER,
          "Event handler must be a function",
          { pattern }
        );
      }

      const subscription = {
        id: crypto.randomUUID(),
        pattern,
        handler,
        options,
        created: new Date().toISOString(),
      };

      this.subscriptions.set(subscription.id, subscription);

      // Handle different subscription types
      if (!pattern.includes("*")) {
        // Direct pattern match (no wildcards)
        this.on(pattern, handler);
      } else if (pattern === "*") {
        // Wildcard pattern - matches all events
        // We need to adapt the handler to handle our new parameter format
        const adaptedHandler = (eventName, data) => handler(data);
        this.on("*", adaptedHandler);
        subscription.adaptedHandler = adaptedHandler; // Store for unsubscribe
      } else {
        // RegexPatern
        const regexPattern = new RegExp(
          "^" + pattern.replace(/\*/g, ".*") + "$"
        );
        // Segment wildcard patterns (e.g., 'user.*', '*.created')
        // This also needs to be updated for the new parameter format
        const patternHandler = (eventName, data) => {
          if (regexPattern.test(eventName)) {
            handler(data);
          }
        };
        this.on("*", patternHandler);
        subscription.patternHandler = patternHandler;
      }
      // Record metric
      this.recordMetric("eventbus.subscriptions", 1, {
        pattern,
      });

      return subscription.id;
    } catch (error) {
      this.handleError(error, {
        method: "subscribe",
        pattern,
        options,
      });

      // Wrap original error
      if (!(error instanceof EventError)) {
        throw new EventError(
          ErrorCodes.EVENT.SUBSCRIPTION_FAILED,
          `Failed to subscribe to pattern: ${pattern}`,
          { pattern, options },
          { cause: error }
        );
      }

      throw error;
    }
  }

  /**
   * Unsubscribe from events
   * @param {string} subscriptionId - Subscription ID
   * @returns {boolean} - Whether the subscription was removed
   */
  unsubscribe(subscriptionId) {
    try {
      const subscription = this.subscriptions.get(subscriptionId);
      if (!subscription) {
        throw new EventError(
          ErrorCodes.EVENT.HANDLER_NOT_FOUND,
          `Subscription ${subscriptionId} not found`,
          { subscriptionId }
        );
      }

      const { pattern, handler, patternHandler, adaptedHandler } = subscription;

      // Remove the appropriate handler
      // Original code
      // if (!pattern.includes("*")) {
      //   this.removeListener(pattern, handler);
      // } else if (pattern === "*") {
      //   // Use adaptedHandler if available
      //   /* istanbul ignore next */
      //   this.removeListener("*", adaptedHandler || handler);
      // } else if (patternHandler) {
      //   this.removeListener("*", patternHandler);
      // }
      if (!pattern.includes("*")) {
        this.removeListener(pattern, handler);
      }
      /* istanbul ignore next */
      if (pattern === '*') {
        this.removeListener('*', adaptedHandler || handler);
      }

      if (patternHandler) {
        this.removeListener("*", patternHandler); // ← now line 464
      }

      // Remove from subscriptions map
      this.subscriptions.delete(subscriptionId);

      // Record metric
      this.recordMetric("eventbus.unsubscriptions", 1, {
        pattern,
      });

      return true;
    } catch (error) {
      this.handleError(error, {
        method: "unsubscribe",
        subscriptionId,
      });

      // Wrap original error
      if (!(error instanceof EventError)) {
        throw new EventError(
          ErrorCodes.EVENT.SUBSCRIPTION_FAILED,
          `Failed to unsubscribe: ${subscriptionId}`,
          { subscriptionId },
          { cause: error }
        );
      }

      throw error;
    }
  }

  /**
   * Queue events for delayed processing
   * @param {Object} event - Event object
   * @param {Object} options - Queue options
   * @returns {Promise<boolean>} - Whether the event was queued
   */
  async queueEvent(event, options = {}) {
    try {
      const queue = this.queues.get(event.name) || [];
      const queueItem = {
        event,
        options,
        timestamp: new Date().toISOString(),
      };

      queue.push(queueItem);
      this.queues.set(event.name, queue);

      // Record metric
      this.recordMetric("eventbus.queued", 1, {
        eventName: event.name,
        queueSize: queue.length,
      });

      // Process queue if immediate
      if (options.immediate) {
        await this.processQueue(event.name);
      }

      return true;
    } catch (error) {
      await this.handleError(error, {
        method: "queueEvent",
        event,
        options,
      });

      throw new EventError(
        ErrorCodes.EVENT.QUEUE_PROCESSING_FAILED,
        `Failed to queue event: ${event.name}`,
        { eventName: event.name, options },
        { cause: error }
      );
    }
  }

  /**
   * Process queued events
   * @param {string} queueName - Queue name
   * @returns {Promise<number>} - Number of processed events
   */
  async processQueue(queueName) {
    try {
      const queue = this.queues.get(queueName) || [];
      let processedCount = 0;

      const startTime = Date.now();

      while (queue.length > 0) {
        const { event } = queue.shift();
        try {
          await super.emit(event.name, event);
          processedCount++;
        } catch (handlerError) {
          throw new EventError(
            ErrorCodes.EVENT.HANDLER_ERROR,
            `Error in handler for event: ${event.name}`,
            { eventName: event.name, eventId: event.id },
            { cause: handlerError }
          );
        }
      }

      this.queues.set(queueName, queue);

      // Record metrics
      this.recordMetric("eventbus.queue.processed", processedCount, {
        queueName,
        processingTime: Date.now() - startTime,
      });

      return processedCount;
    } catch (error) {
      await this.handleError(error, {
        method: "processQueue",
        queueName,
      });

      throw new EventError(
        ErrorCodes.EVENT.QUEUE_PROCESSING_FAILED,
        `Failed to process queue: ${queueName}`,
        { queueName },
        { cause: error }
      );
    }
  }

  /**
   * Process all queued events
   * @returns {Promise<Object>} - Processing results
   */
  async processAllQueues() {
    try {
      const results = {};
      const queueNames = Array.from(this.queues.keys());

      for (const queueName of queueNames) {
        results[queueName] = await this.processQueue(queueName);
      }

      return results;
    } catch (error) {
      await this.handleError(error, {
        method: "processAllQueues",
      });

      throw new EventError(
        ErrorCodes.EVENT.QUEUE_PROCESSING_FAILED,
        "Failed to process all queues",
        {},
        { cause: error }
      );
    }
  }

  /**
   * Track events in history
   * @param {Object} event - Event object
   */
  trackEvent(event) {
    const history = this.history.get(event.name) || [];
    history.unshift(event);

    // Trim history if needed
    if (history.length > this.maxHistorySize) {
      history.pop();
    }

    this.history.set(event.name, history);

    // Record metric
    this.recordMetric("eventbus.history.size", history.length, {
      eventName: event.name,
    });
  }

  /**
   * Get event history
   * @param {string} eventName - Event name
   * @param {Object} options - History options
   * @returns {Array} - Event history
   */
  getHistory(eventName, options = {}) {
    const history = this.history.get(eventName) || [];

    if (options.limit && options.limit > 0) {
      return history.slice(0, options.limit);
    }

    return history;
  }

  /**
   * Get all event history
   * @param {Object} options - History options
   * @returns {Object} - All event history
   */
  getAllHistory(options = {}) {
    const result = {};

    for (const [eventName, history] of this.history) {
      result[eventName] = options.limit
        ? history.slice(0, options.limit)
        : history;
    }

    return result;
  }

  /**
   * Clear history and queues
   * @returns {Promise<void>}
   */
  async reset() {
    this.queues.clear();
    this.history.clear();

    // Only remove event listeners, keep system listeners
    const eventNames = this.eventNames().filter(
      (name) => !name.startsWith("system:")
    );
    for (const eventName of eventNames) {
      this.removeAllListeners(eventName);
    }

    // Record metric
    this.recordMetric("eventbus.reset", 1);
  }

  /**
   * Shutdown the event bus
   * @returns {Promise<void>}
   */
  async shutdown() {
    if (!this.initialized) return;

    try {
      this.state.status = "shutting_down";
      await this.reset();
      this.initialized = false;
      this.state.status = "shutdown";

      // Final shutdown event
      this.emit("system:shutdown", {
        timestamp: new Date().toISOString(),
      });

      // Remove all remaining listeners
      this.removeAllListeners();

      // Record metric
      this.recordMetric("eventbus.shutdown", 1);
    } catch (error) {
      this.state.status = "error";
      await this.handleError(error, { phase: "shutdown" });

      throw new EventError(
        ErrorCodes.EVENT.SHUTDOWN_FAILED,
        "Failed to shutdown EventBus",
        { state: this.state.status },
        { cause: error }
      );
    }
  }
}

/**
 * Factory function for container
 * @param {Object} deps - Dependencies
 * @returns {CoreEventBus} - Event bus instance
 */
export function createEventBus(deps = {}) {
  return new CoreEventBus(deps);
}


// src/core/event/EventBusSystem.js

// src/core/event/EventBusSystem.js

import { EventEmitter } from 'events';
import { CoreEventBus } from './EventBus.js';
import { CoreError, EventError, ErrorCodes, ServiceError } from '../errors/index.js';

export class EventBusSystem extends EventEmitter {
  static dependencies = ['errorSystem', 'config'];
  static version = '1.0.0';

  constructor(deps) {
    super();
    this.deps = deps;
    this.eventBus = null;
    this.initialized = false;
    // Remove static flag and use an instance flag instead
    this._forwardingInitialized = false;
    
    // Enhanced state tracking
    this.state = {
      status: 'created',
      startTime: null,
      errors: [],
      metrics: new Map(),
      healthChecks: new Map()
    };
    
    // Set up default health checks
    this.setupDefaultHealthChecks();
  }

  /**
   * Set up default health checks
   * @private
   */
  setupDefaultHealthChecks() {
    // Register default health check for state
    this.registerHealthCheck('state', async () => {
      return {
        status: this.initialized ? 'healthy' : 'unhealthy',
        uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
        errorCount: this.state.errors.length
      };
    });

    // Register health check for eventBus if available
    this.registerHealthCheck('eventBus', async () => {
      if (!this.eventBus) {
        return {
          status: 'unhealthy',
          reason: 'EventBus not initialized'
        };
      }
      
      try {
        // Check eventBus health if it has a checkHealth method
        if (typeof this.eventBus.checkHealth === 'function') {
          return await this.eventBus.checkHealth();
        } else {
          return {
            status: 'healthy',
            details: 'EventBus instance exists but does not support health checks'
          };
        }
      } catch (error) {
        return {
          status: 'error',
          error: error.message
        };
      }
    });
  }

  /**
   * Register a health check function
   * @param {string} name - Health check name
   * @param {Function} checkFn - Health check function
   */
  registerHealthCheck(name, checkFn) {
    if (typeof checkFn !== 'function') {
      throw new EventError(
        ErrorCodes.EVENT.INVALID_HANDLER,
        `Health check ${name} must be a function`,
        { checkName: name }
      );
    }
    this.state.healthChecks.set(name, checkFn);
  }

  /**
   * Perform health checks
   * @returns {Object} Health check results
   */
  async checkHealth() {
    const results = {};
    let overallStatus = 'healthy';

    for (const [name, checkFn] of this.state.healthChecks) {
      try {
        results[name] = await checkFn();
        if (results[name].status !== 'healthy') {
          overallStatus = 'unhealthy';
        }
      } catch (error) {
        results[name] = {
          status: 'error',
          error: error.message
        };
        overallStatus = 'unhealthy';
      }
    }

    return {
      name: 'EventBusSystem',
      version: EventBusSystem.version,
      status: overallStatus,
      timestamp: new Date().toISOString(),
      checks: results
    };
  }

  /**
   * Record a metric
   * @param {string} name - Metric name
   * @param {*} value - Metric value
   * @param {Object} tags - Metric tags
   */
  recordMetric(name, value, tags = {}) {
    this.state.metrics.set(name, {
      value,
      timestamp: Date.now(),
      tags
    });
  }

  /**
   * Get all recorded metrics
   * @returns {Object} All metrics
   */
  getMetrics() {
    const metrics = {};
    
    for (const [name, data] of this.state.metrics) {
      metrics[name] = data;
    }
    
    return metrics;
  }

  /**
   * Get system status
   * @returns {Object} System status
   */
  getStatus() {
    return {
      name: 'EventBusSystem',
      version: EventBusSystem.version,
      status: this.state.status,
      uptime: this.state.startTime ? Date.now() - this.state.startTime : 0, 
      initialized: this.initialized,
      errorCount: this.state.errors.length,
      timestamp: new Date().toISOString()
    };
  }

  /**
   * Validate dependencies
   * @private
   */
  validateDependencies() {
    const missing = this.constructor.dependencies.filter(
      dep => !this.deps[dep]
    );

    if (missing.length > 0) {
      throw new EventError(
        ErrorCodes.EVENT.MISSING_DEPENDENCIES,
        `Missing required dependencies: ${missing.join(', ')}`,
        { missingDeps: missing }
      );
    }

    // Validate errorSystem if present
    if (this.deps.errorSystem && typeof this.deps.errorSystem.handleError !== 'function') {
      throw new EventError(
        ErrorCodes.EVENT.INVALID_DEPENDENCY,
        'ErrorSystem missing required method: handleError',
        { dependency: 'errorSystem' }
      );
    }
  }

  /**
   * Initialize the event bus system
   * @returns {Promise<EventBusSystem>} - The initialized system
   */
  async initialize() {
    if (this.initialized) {
      throw new EventError(
        ErrorCodes.EVENT.INITIALIZATION, 
        'EventBusSystem is already initialized',
        { state: this.state.status }
      );
    }

    try {
      // Validate dependencies
      this.validateDependencies();
      
      // Update state
      this.state.status = 'initializing';
      this.state.startTime = Date.now();
      
      // Create and initialize event bus
      this.eventBus = new CoreEventBus(this.deps);
      
      // Set up event forwarding from eventBus to system
      this.setupEventForwarding();
      
      await this.eventBus.initialize();

      this.initialized = true;
      this.state.status = 'running';
      
      // Record metric
      this.recordMetric('eventbussystem.initialized', 1);
      
      // Emit system initialized event
      this.emit('system:initialized', {
        timestamp: new Date().toISOString()
      });
      
      return this;
    } catch (error) {
      // Update state
      this.state.status = 'error';
      
      // Record error in state
      this.state.errors.push({
        timestamp: new Date().toISOString(),
        error: error.message,
        context: { phase: 'initialization' }
      });
      
      // Record metric
      this.recordMetric('eventbussystem.initialization.failed', 1, {
        errorMessage: error.message
      });
      
      await this.handleError(error);
      
      // Wrap the error
      if (!(error instanceof EventError)) {
        throw new EventError(
          ErrorCodes.EVENT.INITIALIZATION,
          'Failed to initialize EventBusSystem',
          { originalError: error.message },
          { cause: error }
        );
      }
      
      throw error;
    }
  }

  /**
   * Set up event forwarding from eventBus to system
   * @private
   */
  setupEventForwarding() {
    if (!this.eventBus) {
      //console.log('DEBUG: setupEventForwarding - eventBus is null, returning');
      return;
    }
    
    // Use instance property to prevent multiple setup
    if (this._forwardingInitialized) {
      //console.log('DEBUG: setupEventForwarding - already initialized, returning');
      return;
    }
    
    //console.log('DEBUG: Setting up event forwarding');
    this._forwardingInitialized = true;
    
    // Add direct listeners for test-specific events
    this.eventBus.on('system:test', (event) => {
      //console.log('DEBUG: Received direct system:test event:', event);
      super.emit('system:test', event);
    });
    
    this.eventBus.on('wildcard:test', (event) => {
      //console.log('DEBUG: Received direct wildcard:test event:', event);
      super.emit('wildcard:test', event);
    });
    
    // Listen for all events on the eventBus and forward them
    this.eventBus.on('*', (event) => {
      //console.log('DEBUG: Wildcard listener received event:', event);
      
      // Only forward if it's an event object with a name
      if (event && event.name) {
        //console.log('DEBUG: Forwarding event with name:', event.name);
        
        // Forward non-system events to system level
        if (!event.name.startsWith('system:')) {
          //console.log('DEBUG: Emitting non-system event to super');
          super.emit(event.name, event);
        }
      } else {
        //console.log('DEBUG: Event missing name property or is invalid:', event);
      }
    });
  }

  /**
   * Enhanced emit with forwarding to eventBus
   * @param {string} eventName - Event name
   * @param {...any} args - Event arguments
   * @returns {boolean} - Whether the event had listeners
   */
  async emit(eventName, ...args) {
    // Local EventEmitter emission (use super to avoid recursion)
    const localEmitResult = super.emit(eventName, ...args);
    
    // Forward to eventBus if available and initialized
    // Don't forward system events to avoid loops
    if (this.initialized && this.eventBus && 
        typeof this.eventBus.emit === 'function' && 
        !eventName.startsWith('system:')) {
      try {
        await this.eventBus.emit(eventName, ...args);
      } catch (error) {
        await this.handleError(error, {
          method: 'emit',
          eventName,
          args
        });
      }
    }
    
    return localEmitResult;
  }

  /**
   * Handle errors with proper context
   * @param {Error} error - Error object
   * @param {Object} context - Error context
   * @returns {Promise<void>}
   */
  async handleError(error, context = {}) {
    // Add error to state
    this.state.errors.push({
      timestamp: new Date().toISOString(),
      error: error.message,
      context: context || {}
    });
    
    // Trim error history if needed
    if (this.state.errors.length > 100) {
      this.state.errors.shift();
    }
    
    // Record metric
    this.recordMetric('eventbussystem.errors', 1, {
      errorType: error.constructor.name,
      errorCode: error.code
    });
    
    // Forward to error system if available
    if (this.deps.errorSystem) {
      try {
        await this.deps.errorSystem.handleError(error, {
          source: 'EventBusSystem',
          ...context
        });
      } catch (handlerError) {
        // Special handling when error system fails
        this.state.errors.push({
          timestamp: new Date().toISOString(),
          error: handlerError.message,
          context: { phase: 'error-handling' }
        });
      }
    }
  }

  /**
   * Get the event bus instance
   * @returns {CoreEventBus} Event bus instance
   */
  getEventBus() {
    if (!this.initialized) {
      throw new EventError(
        ErrorCodes.EVENT.NOT_INITIALIZED,
        'EventBusSystem is not initialized',
        { state: this.state.status }
      );
    }
    return this.eventBus;
  }

  /**
   * Shutdown the event bus system
   * @returns {Promise<EventBusSystem>} - This instance
   */
  async shutdown() {
    if (!this.initialized) return this;

    try {
      this.state.status = 'shutting_down';
      
      // Record metric
      this.recordMetric('eventbussystem.shutdown', 1);
      
      // Shutdown eventBus
      if (this.eventBus) {
        await this.eventBus.shutdown();
      }
      
      this.initialized = false;
      this.eventBus = null;
      this.state.status = 'shutdown';
      
      // Emit system shutdown event
      this.emit('system:shutdown', {
        timestamp: new Date().toISOString()
      });
      
      return this;
    } catch (error) {
      this.state.status = 'error';
      
      // Record error in state
      this.state.errors.push({
        timestamp: new Date().toISOString(),
        error: error.message,
        context: { phase: 'shutdown' }
      });
      
      // Record metric
      this.recordMetric('eventbussystem.shutdown.failed', 1, {
        errorMessage: error.message
      });
      
      await this.handleError(error, { phase: 'shutdown' });
      
      // Wrap the error
      if (!(error instanceof EventError)) {
        throw new EventError(
          ErrorCodes.EVENT.SHUTDOWN_FAILED,
          'Failed to shutdown EventBusSystem',
          { state: this.state.status },
          { cause: error }
        );
      }
      
      throw error;
    }
  }
}

/**
 * Factory function for container
 * @param {Object} deps - Dependencies
 * @returns {EventBusSystem} - Event bus system instance
 */
export function createEventBusSystem(deps = {}) {
  // Provide default dependencies if needed
  const defaultDeps = {
    errorSystem: deps.errorSystem || {
      handleError: async () => {} // No-op handler if not provided
    },
    config: deps.config || {} // Empty config if not provided
  };

  // Create and return the EventBusSystem instance
  return new EventBusSystem({
    ...defaultDeps,
    ...deps
  });
}


// src/core/event/event-bus-docs.md

# Event System Documentation

## Table of Contents
1. [Overview](#overview)
2. [Core Concepts](#core-concepts)
3. [System Architecture](#system-architecture)
4. [Core Components](#core-components)
5. [State Management](#state-management)
6. [Error Handling](#error-handling)
7. [Event Management](#event-management)
8. [Health Monitoring](#health-monitoring)
9. [Metrics Tracking](#metrics-tracking)
10. [System Lifecycle](#system-lifecycle)
11. [Dependency Validation](#dependency-validation)
12. [Status Reporting](#status-reporting)
13. [Testing Strategy](#testing-strategy)
14. [Best Practices](#best-practices)
15. [Using EventBus in Modules](#using-eventbus-in-modules)
16. [Troubleshooting](#troubleshooting)
17. [Areas for Improvement](#areas-for-improvement)

## Overview

The EventBus system provides centralized event management and message broker functionality for the TSMIS architecture. It serves as the communication backbone between modules while maintaining system boundaries and proper dependency management. The EventBus enables loose coupling between modules through an event-driven architecture pattern.

### Core Dependencies
```javascript
static dependencies = ['errorSystem', 'config'];
```

### Key Features
- Centralized event management
- Module-to-module communication
- Event history tracking
- Message queuing
- Pattern-based event subscription
- Error handling integration
- Health monitoring
- Metrics tracking
- Status reporting
- Dependency validation

## Core Concepts

### Event-Driven Communication

The EventBus system implements the publish-subscribe pattern (pub/sub) where:
- Publishers emit events without knowledge of subscribers
- Subscribers listen for events without knowledge of publishers
- Events carry data and metadata
- Communication is asynchronous and decoupled

### Core Dependencies

The EventBus system requires two essential dependencies:

```javascript
static dependencies = ['errorSystem', 'config'];
```

#### Dependency Resolution

Dependencies are resolved through one of these methods:

1. **Container Resolution** (primary method)
   - Dependencies are automatically injected by the Container
   - Container manages lifecycle and dependencies

2. **Default Fallbacks** (development/testing)
   - Default implementations for easier testing and development

3. **Explicit Injection**
   - Manual dependency injection for specialized cases

#### Default Fallbacks

```javascript
const defaultDeps = {
  errorSystem: deps.errorSystem || {
    handleError: async () => {} // No-op handler if not provided
  },
  config: deps.config || {} // Empty config if not provided
};

// Create and return the EventBusSystem instance
return new EventBusSystem({
  ...defaultDeps,
  ...deps
});
```

### Event Structure

Events in the system follow a standardized structure:

```javascript
const event = {
  id: crypto.randomUUID(),      // Unique event identifier
  name: eventName,              // Event name (e.g., 'user.created')
  data: payload,                // Event payload
  timestamp: new Date().toISOString(), // Event creation time
  metadata: options.metadata || {}    // Additional metadata
};
```

### Subscription Types

The EventBus supports several types of subscriptions:

1. **Direct Subscriptions**
   - Exact event name match
   ```javascript
   eventBus.subscribe('user.created', handler);
   
    // handler receives: (event)
    // where event = { id, name, data, timestamp, metadata }
    ```

2. **Wildcard Subscriptions**
   - Match all events
   - Automatically receive forwarded copies of all non-wildcard events
   ```javascript
   eventBus.subscribe('*', handler);
   
   // handler receives: (event)
   // where event = { id, name, data, timestamp, metadata }
   ```

3. **Pattern-Based Subscriptions**
   - Match events based on patterns
   ```javascript
   eventBus.subscribe('user.*', handler); // All user events
   eventBus.subscribe('*.created', handler); // All creation events

    // handler receives: (event)
   // where event = { id, name, data, timestamp, metadata }
   ```


#### Wildcard Event Handling

The EventBus supports wildcard event listening through a special '*' event pattern. When a wildcard listener is added:

1. The system sets up special event forwarding.
2. All events are automatically forwarded to wildcard subscribers.
3. Wildcard subscribers receive events in the same format as direct subscribers.

```javascript
eventBus.subscribe('*', (event) => {
  console.log(`Received event: ${event.name}`);
  console.log(`Event data:`, event.data);
});

// All events will be forwarded to this handler with a consistent format
```



### Event Queuing

Events can be queued for delayed processing:

```javascript
// Queue event
await eventBus.emit('user.created', userData, { queue: true });

// Process all queued 'user.created' events
await eventBus.processQueue('user.created');

// Process all queued events
await eventBus.processAllQueues();
```

## System Architecture

### Architecture Flow
```mermaid
graph TB
    Container --> EventBusSystem
    EventBusSystem --> CoreEventBus
    
    CoreEventBus --> |Events| ModuleA[Module A]
    CoreEventBus --> |Events| ModuleB[Module B]
    
    ModuleA --> |Emit| CoreEventBus
    ModuleB --> |Emit| CoreEventBus
    
    ErrorSystem --> |Error Handling| CoreEventBus
    EventError --> |Specialized Errors| CoreEventBus
    EventError --> |Specialized Errors| EventBusSystem
```

### Integration with Other Systems

The EventBus system integrates with:

1. **ErrorSystem**
   - Error handling and forwarding
   - Error context enrichment
   - Error history management
   - Specialized EventError type

2. **ModuleSystem**
   - Inter-module communication
   - Module lifecycle events
   - Module health monitoring

3. **CoreContainer**
   - Dependency injection
   - Lifecycle management

## Core Components

### CoreEventBus

The CoreEventBus is the fundamental event handling component:

```javascript
export class CoreEventBus extends EventEmitter {
  static dependencies = ['errorSystem', 'config'];
  static version = '1.0.0';

  constructor(deps = {}) {
    super();
    this.deps = deps;
    this.queues = new Map();
    this.subscriptions = new Map();
    this.history = new Map();
    this.maxHistorySize = deps.config?.eventHistory?.maxSize || 1000;
    this.initialized = false;
    this.state = {
      status: 'created',
      startTime: null,
      metrics: new Map(),
      errors: [],
      healthChecks: new Map()
    };
  }

  // Core methods
  async initialize() { /* ... */ }
  async emit(eventName, data, options = {}) { /* ... */ }
  subscribe(pattern, handler, options = {}) { /* ... */ }
  unsubscribe(subscriptionId) { /* ... */ }
  async queueEvent(event, options = {}) { /* ... */ }
  async processQueue(queueName) { /* ... */ }
  async processAllQueues() { /* ... */ }
  async reset() { /* ... */ }
  async shutdown() { /* ... */ }
  
  // Health monitoring
  async checkHealth() { /* ... */ }
  registerHealthCheck(name, checkFn) { /* ... */ }
  
  // History and metrics
  trackEvent(event) { /* ... */ }
  getHistory(eventName, options = {}) { /* ... */ }
  getAllHistory(options = {}) { /* ... */ }
  recordMetric(name, value, tags = {}) { /* ... */ }
}
```

### EventBusSystem

The EventBusSystem manages the CoreEventBus and provides system-level functionality:

```javascript
export class EventBusSystem extends EventEmitter {
  static dependencies = ['errorSystem', 'config'];
  static version = '1.0.0';

  constructor(deps) {
    super();
    this.deps = deps;
    this.eventBus = null;
    this.initialized = false;
    this.state = {
      status: 'created',
      startTime: null,
      metrics: new Map(),
      errors: [],
      healthChecks: new Map()
    };
  }

  // Core methods
  async initialize() { /* ... */ }
  getEventBus() { /* ... */ }
  async shutdown() { /* ... */ }
  
  // Health monitoring
  async checkHealth() { /* ... */ }
  registerHealthCheck(name, checkFn) { /* ... */ }
  
  // Status and metrics
  getStatus() { /* ... */ }
  getMetrics() { /* ... */ }
  recordMetric(name, value, tags = {}) { /* ... */ }
  
  // Event forwarding
  setupEventForwarding() { /* ... */ }
  async emit(eventName, ...args) { /* ... */ }
  
  // Dependency validation
  validateDependencies() { /* ... */ }
}
```

## State Management

### EventBus States

Both CoreEventBus and EventBusSystem transition through the following states during their lifecycle:

- **created**: Initial state after instantiation
- **initializing**: During initialization process
- **running**: System is active and operational
- **shutting_down**: During shutdown process
- **shutdown**: System is inactive
- **error**: Error state when something fails

### State Tracking

The state object stores comprehensive system metadata:

```javascript
this.state = {
  status: 'created',          // Current system state
  startTime: null,            // When system was started
  errors: [],                 // Error history
  metrics: new Map(),         // Performance metrics
  healthChecks: new Map()     // Health check functions
};
```

### Metrics Tracking

The EventBus system tracks various metrics:

```javascript
// Record a metric
eventBus.recordMetric('events.processed', 42, { 
  eventType: 'user.created',
  source: 'userModule'
});

// Get metrics
const metrics = eventBusSystem.getMetrics();
```

Key metrics include:
- Event emission counts
- Subscription counts
- Queue sizes
- Processing times
- Error counts

## Error Handling

### EventError Type

The EventBus system utilizes a specialized `EventError` type for event-related errors:

```javascript
import { CoreError } from '../Error.js';

/**
 * Event system related errors
 * @extends CoreError
 */
export class EventError extends CoreError {
  /**
   * Create a new EventError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`EVENT_${code}`, message, details, options);
    this.statusCode = 500;
  }
}
```

### Event Error Codes

The system defines specific error codes for event-related errors:

```javascript
// Event related error codes
EVENT: {
  INITIALIZATION_FAILED: 'INITIALIZATION_FAILED',
  EMISSION_FAILED: 'EMISSION_FAILED',
  SUBSCRIPTION_FAILED: 'SUBSCRIPTION_FAILED',
  INVALID_PATTERN: 'INVALID_PATTERN',
  INVALID_EVENT_NAME: 'INVALID_EVENT_NAME',
  INVALID_HANDLER: 'INVALID_HANDLER',
  QUEUE_PROCESSING_FAILED: 'QUEUE_PROCESSING_FAILED',
  HANDLER_NOT_FOUND: 'HANDLER_NOT_FOUND',
  HANDLER_ERROR: 'HANDLER_ERROR',
  NOT_INITIALIZED: 'NOT_INITIALIZED',
  SHUTDOWN_FAILED: 'SHUTDOWN_FAILED',
  MISSING_DEPENDENCIES: 'MISSING_DEPENDENCIES',
  INVALID_DEPENDENCY: 'INVALID_DEPENDENCY'
}
```

### Error Management

Both CoreEventBus and EventBusSystem include robust error handling:

```javascript
async handleError(error, context = {}) {
  // Add error to state
  this.state.errors.push({
    timestamp: new Date().toISOString(),
    error: error.message,
    context: context || {}
  });
  
  // Trim error history if needed
  if (this.state.errors.length > 100) {
    this.state.errors.shift();
  }
  
  // Record metric
  this.recordMetric('eventbus.errors', 1, {
    errorType: error.constructor.name,
    errorCode: error.code
  });
  
  // Forward to error system if available
  if (this.deps.errorSystem) {
    try {
      await this.deps.errorSystem.handleError(error, {
        source: 'CoreEventBus', // or 'EventBusSystem'
        ...context
      });
    } catch (handlerError) {
      // Special handling when error system fails
      this.state.errors.push({
        timestamp: new Date().toISOString(),
        error: handlerError.message,
        context: { phase: 'error-handling' }
      });
    }
  }
}
```

### Error Propagation

Errors during event emission are handled gracefully:

```javascript
async emit(eventName, data, options = {}) {
  try {
    // Validate event name
    if (!eventName || typeof eventName !== 'string') {
      throw new EventError(
        ErrorCodes.EVENT.INVALID_EVENT_NAME,
        'Event name must be a non-empty string',
        { providedEventName: eventName }
      );
    }

    // Event emission logic
    // ...
  } catch (error) {
    await this.handleError(error, {
      eventName,
      data,
      options
    });
    
    // Wrap original error if needed
    if (!(error instanceof EventError)) {
      throw new EventError(
        ErrorCodes.EVENT.EMISSION_FAILED,
        `Failed to emit event: ${eventName}`,
        { eventName, options },
        { cause: error }
      );
    }
    
    throw error;
  }
}
```

### Error Handling in Event Handlers

When implementing event handlers, always use try/catch:

```javascript
eventBus.subscribe('user.created', async (event) => {
  try {
    // Handle event
    await processUser(event.data);
  } catch (error) {
    // Forward to error system
    await module.handleError(error, { 
      event, 
      handler: 'processNewUser' 
    });
  }
});
```

## Event Management

### Event Emission

Events can be emitted with various options:

```javascript
// Basic event emission
await eventBus.emit('user.created', {
  id: 'user-123',
  name: 'John Doe',
  email: 'john@example.com'
});

// Event with metadata
await eventBus.emit('user.created', userData, {
  metadata: {
    source: 'registration-form',
    ip: '192.168.1.1'
  }
});

// Queued event
await eventBus.emit('bulk.process', largeDataset, {
  queue: true
});

// Immediate queue processing
await eventBus.emit('notification.send', notification, {
  queue: true,
  immediate: true
});
```

### Event Subscription

Modules can subscribe to events in several ways:

```javascript
// Direct subscription
const subId = eventBus.subscribe('user.created', handleUserCreated);

// Wildcard subscription (all events)
eventBus.subscribe('*', logAllEvents);

// Pattern subscription (all user events)
eventBus.subscribe('user.*', handleUserEvents);

// Pattern subscription (all creation events)
eventBus.subscribe('*.created', handleCreationEvents);

// Unsubscribe
eventBus.unsubscribe(subId);
```

### Event History

The EventBus maintains a history of emitted events:

```javascript
// Get history for a specific event
const userCreatedEvents = eventBus.getHistory('user.created');

// Limit history results
const recentUserEvents = eventBus.getHistory('user.created', { limit: 10 });

// Get all event history
const allHistory = eventBus.getAllHistory();
```

### Queue Management

Events can be queued and processed in batches:

```javascript
// Process a specific queue
await eventBus.processQueue('email.send');

// Process all queues
await eventBus.processAllQueues();
```

### Enhanced Event Forwarding

The EventBusSystem includes improved event forwarding to avoid loops:

```javascript
setupEventForwarding() {
  if (!this.eventBus) return;
  
  // Listen for all events on the eventBus and forward them
  this.eventBus.on('*', (eventName, event) => {
    // Forward non-system events to system
    if (!eventName.startsWith('system:')) {
      super.emit(eventName, event);
    }
  });
  
  // Listen for system events specifically to avoid duplication
  this.eventBus.on('system:*', (eventName, event) => {
    // Forward to system level
    super.emit(eventName, event);
  });
}
```

## Health Monitoring

### Health Check Implementation

The EventBus system includes comprehensive health monitoring:

```javascript
// Register a custom health check
eventBus.registerHealthCheck('connection', async () => {
  const connected = await checkConnection();
  return {
    status: connected ? 'healthy' : 'unhealthy',
    details: { connected }
  };
});

// Get health status
const health = await eventBus.checkHealth();
```

### Default Health Checks

CoreEventBus includes these default health checks:

1. **state**: System state check
   - Checks if the system is initialized and running
   - Reports uptime and error count

2. **queues**: Queue health check
   - Reports queue sizes and total queued events
   - Monitors for queue buildup

3. **subscriptions**: Subscription check
   - Reports subscription count and patterns
   - Ensures event handlers are registered

EventBusSystem includes these default health checks:

1. **state**: System state check
   - Checks if the system is initialized and running
   - Reports uptime and error count

2. **eventBus**: EventBus health check
   - Forwards to the CoreEventBus health check if available
   - Reports status of the underlying event bus

### Health Check Results

Health check results follow a consistent format:

```javascript
{
  name: 'CoreEventBus',
  version: '1.0.0',
  status: 'healthy', // or 'unhealthy', 'error'
  timestamp: '2024-03-27T12:34:56.789Z',
  checks: {
    state: {
      status: 'healthy',
      uptime: 3600000, // ms
      errorCount: 0
    },
    queues: {
      status: 'healthy',
      queueCount: 2,
      totalQueuedEvents: 10,
      queues: {
        'email.send': 8,
        'notification.push': 2
      }
    },
    subscriptions: {
      status: 'healthy',
      count: 5,
      patterns: ['user.created', 'user.updated', 'system.*', '*', 'email.*']
    }
  }
}
```

## Metrics Tracking

The EventBus system provides comprehensive metrics tracking:

```javascript
// Record a metric
eventBusSystem.recordMetric('eventbussystem.events.processed', 42, { 
  eventType: 'user.created' 
});

// Get all metrics
const metrics = eventBusSystem.getMetrics();
console.log('System metrics:', metrics);

// Output format:
{
  "eventbussystem.events.processed": {
    "value": 42,
    "timestamp": 1711541696000,
    "tags": {
      "eventType": "user.created"
    }
  },
  "eventbussystem.initialized": {
    "value": 1,
    "timestamp": 1711541695000,
    "tags": {}
  }
}
```

Key metrics automatically tracked by the system:

- `eventbussystem.initialized`: Records when initialization completes
- `eventbussystem.shutdown`: Records when shutdown completes
- `eventbussystem.errors`: Records error occurrences
- `eventbussystem.initialization.failed`: Records initialization failures
- `eventbussystem.shutdown.failed`: Records shutdown failures
- `eventbus.events.emitted`: Records event emissions
- `eventbus.subscriptions`: Records subscription additions
- `eventbus.unsubscriptions`: Records subscription removals
- `eventbus.queued`: Records event queuing
- `eventbus.queue.processed`: Records queue processing

## System Lifecycle

### Initialization

The EventBusSystem initialization process:

```javascript
async initialize() {
  if (this.initialized) {
    throw new EventError(
      ErrorCodes.EVENT.INITIALIZATION_FAILED, 
      'EventBusSystem is already initialized',
      { state: this.state.status }
    );
  }

  try {
    // Validate dependencies
    this.validateDependencies();
    
    // Update state
    this.state.status = 'initializing';
    this.state.startTime = Date.now();

    // Create and initialize event bus
    this.eventBus = new CoreEventBus(this.deps);
    
    // Set up event forwarding
    this.setupEventForwarding();
    
    await this.eventBus.initialize();

    this.initialized = true;
    this.state.status = 'running';
    
    // Record metric
    this.recordMetric('eventbussystem.initialized', 1);
    
    // Emit initialization event
    this.emit('system:initialized', {
      timestamp: new Date().toISOString()
    });
    
    return this;
  } catch (error) {
    this.state.status = 'error';
    this.state.errors.push({
      timestamp: new Date().toISOString(),
      error: error.message,
      context: { phase: 'initialization' }
    });
    
    // Record metric
    this.recordMetric('eventbussystem.initialization.failed', 1, {
      errorMessage: error.message
    });
    
    await this.handleError(error);
    
    // Wrap the error
    if (!(error instanceof EventError)) {
      throw new EventError(
        ErrorCodes.EVENT.INITIALIZATION_FAILED,
        'Failed to initialize EventBusSystem',
        { originalError: error.message },
        { cause: error }
      );
    }
    
    throw error;
  }
}
```

### Shutdown

The EventBusSystem shutdown process:

```javascript
async shutdown() {
  if (!this.initialized) return this;

  try {
    this.state.status = 'shutting_down';
    
    // Record metric
    this.recordMetric('eventbussystem.shutdown', 1);
    
    // Shutdown eventBus
    if (this.eventBus) {
      await this.eventBus.shutdown();
    }
    
    this.initialized = false;
    this.eventBus = null;
    this.state.status = 'shutdown';
    
    // Emit system shutdown event
    this.emit('system:shutdown', {
      timestamp: new Date().toISOString()
    });
    
    return this;
  } catch (error) {
    this.state.status = 'error';
    this.state.errors.push({
      timestamp: new Date().toISOString(),
      error: error.message,
      context: { phase: 'shutdown' }
    });
    
    // Record metric
    this.recordMetric('eventbussystem.shutdown.failed', 1, {
      errorMessage: error.message
    });
    
    await this.handleError(error, { phase: 'shutdown' });
    
    // Wrap the error
    if (!(error instanceof EventError)) {
      throw new EventError(
        ErrorCodes.EVENT.SHUTDOWN_FAILED,
        'Failed to shutdown EventBusSystem',
        { state: this.state.status },
        { cause: error }
      );
    }
    
    throw error;
  }
}
```

### Container Registration

Register the EventBusSystem with the container in your application:

```javascript
// src/app.js
import { createEventBusSystem } from './core/event/EventBusSystem.js';

// Register with container
container.register('eventBusSystem', createEventBusSystem);

// Registration order
container.register('errorSystem', createErrorSystem);
container.register('config', () => ({}));
container.register('eventBusSystem', createEventBusSystem);
container.register('moduleSystem', createModuleSystem);
```

## Dependency Validation

The EventBusSystem performs thorough dependency validation:

```javascript
validateDependencies() {
  const missing = this.constructor.dependencies.filter(
    dep => !this.deps[dep]
  );

  if (missing.length > 0) {
    throw new EventError(
      ErrorCodes.EVENT.MISSING_DEPENDENCIES,
      `Missing required dependencies: ${missing.join(', ')}`,
      { missingDeps: missing }
    );
  }

  // Validate errorSystem if present
  if (this.deps.errorSystem && typeof this.deps.errorSystem.handleError !== 'function') {
    throw new EventError(
      ErrorCodes.EVENT.INVALID_DEPENDENCY,
      'ErrorSystem missing required method: handleError',
      { dependency: 'errorSystem' }
    );
  }
}
```

This validation ensures:
- All required dependencies are provided
- Dependencies implement expected interfaces
- Early failure if dependency requirements aren't met

## Status Reporting

The EventBusSystem provides a `getStatus()` method for system monitoring:

```javascript
// Get system status
const status = eventBusSystem.getStatus();
console.log('EventBusSystem status:', JSON.stringify(status, null, 2));

// Status object format:
{
  "name": "EventBusSystem",
  "version": "1.0.0",
  "status": "running", // 'created', 'initializing', 'running', 'shutting_down', 'shutdown', 'error'
  "uptime": 3600000, // ms since start
  "initialized": true,
  "errorCount": 0,
  "timestamp": "2024-03-27T12:34:56.789Z"
}
```

The status report provides:
- Current system state
- System uptime
- Initialization status
- Error count
- Timestamp

## Testing Strategy

### EventBus Testing

Example of testing the CoreEventBus:

```javascript
describe('CoreEventBus', () => {
  let eventBus;
  let mockErrorSystem;
  
  beforeEach(() => {
    // Create mock dependencies
    mockErrorSystem = {
      handleError: jest.fn()
    };
    
    // Create EventBus instance
    eventBus = new CoreEventBus({
      errorSystem: mockErrorSystem,
      config: {
        eventHistory: {
          maxSize: 5
        }
      }
    });
  });
  
  afterEach(() => {
    // Clean up
    if (eventBus.initialized) {
      eventBus.shutdown();
    }
  });
  
  test('should emit events', async () => {
    await eventBus.initialize();
    
    const handler = jest.fn();
    eventBus.on('test.event', handler);
    
    await eventBus.emit('test.event', { message: 'Hello' });
    
    expect(handler).toHaveBeenCalled();
    expect(handler.mock.calls[0][0]).toHaveProperty('name', 'test.event');
    expect(handler.mock.calls[0][0]).toHaveProperty('data', { message: 'Hello' });
  });
  
  test('should throw EventError for invalid event name', async () => {
    await eventBus.initialize();
    
    await expect(eventBus.emit(null, { data: 'test' }))
      .rejects
      .toThrow(EventError);
  });
  
  // More tests...
});
```

### EventBusSystem Testing

Example of testing the EventBusSystem:

```javascript
describe('EventBusSystem', () => {
  let eventBusSystem;
  let mockErrorSystem;
  
  beforeEach(() => {
    mockErrorSystem = {
      handleError: jest.fn()
    };
    
    eventBusSystem = new EventBusSystem({
      errorSystem: mockErrorSystem,
      config: {}
    });
  });
  
  afterEach(async () => {
    if (eventBusSystem.initialized) {
      await eventBusSystem.shutdown();
    }
  });
  
  test('should initialize correctly', async () => {
    await eventBusSystem.initialize();
    
    expect(eventBusSystem.initialized).toBe(true);
    expect(eventBusSystem.state.status).toBe('running');
    expect(eventBusSystem.eventBus).toBeInstanceOf(CoreEventBus);
  });
  
  test('should validate dependencies', async () => {
    const invalidSystem = new EventBusSystem({});
    await expect(invalidSystem.initialize())
      .rejects
      .toThrow(EventError);
  });
  
  // More tests...
});
```

### Testing Event Handlers

Example of testing a module's event handlers:

```javascript
describe('UserModule event handlers', () => {
  let userModule;
  let mockEventBus;
  
  beforeEach(() => {
    // Create mock event bus
    mockEventBus = {
      subscribe: jest.fn(),
      emit: jest.fn()
    };
    
    // Create mock event bus system
    const mockEventBusSystem = {
      getEventBus: () => mockEventBus
    };
    
    // Create module with mocked dependencies
    userModule = new UserModule({
      eventBusSystem: mockEventBusSystem,
      // Other dependencies...
    });
  });
  
  test('should handle user.created events', async () => {
    // Extract the handler function
    await userModule.setupEventHandlers();
    const [[eventName, handler]] = mockEventBus.subscribe.mock.calls;
    
    expect(eventName).toBe('user.created');
    
    // Create a mock event
    const mockEvent = {
      id: 'event-123',
      name: 'user.created',
      data: { id: 'user-123', name: 'John Doe' },
      timestamp: new Date().toISOString()
    };
    
    // Call the handler directly
    await handler(mockEvent);
    
    // Assert expected behavior
    // ...
  });
});
```

## Best Practices

### 1. Event Naming

Follow these event naming conventions:

- Use domain-driven event names: `domain.action`
- Include version for breaking changes: `user.created.v2`
- Use past tense for state changes: `user.created`, `order.completed`
- Use present tense for commands: `notification.send`, `email.process`
- Be specific and descriptive

Examples:
```javascript
// Good
eventBus.emit('user.registered', userData);
eventBus.emit('order.completed', orderData);
eventBus.emit('payment.failed', paymentError);

// Bad - too generic
eventBus.emit('created', userData);
eventBus.emit('process', orderData);
```

### 2. Event Data Structure

Follow these guidelines for event data:

- Keep event data serializable (JSON-compatible)
- Include all necessary context in the data
- Avoid circular references
- Use consistent data structures for similar events
- Don't include sensitive information

Example:
```javascript
// Good
await eventBus.emit('user.created', {
  id: 'user-123',
  name: 'John Doe',
  email: 'john@example.com',
  createdAt: new Date().toISOString(),
  roles: ['user'],
  settings: {
    notifications: true,
    theme: 'dark'
  }
});

// Bad - includes DB model, sensitive data
await eventBus.emit('user.created', userDbModel);
```

### 3. Event Handling

Implement robust event handlers:

- Always use try/catch in handlers
- Validate event data before processing
- Keep handlers focused on a single responsibility
- Use proper error context
- Make handlers idempotent when possible

Example:
```javascript
eventBus.subscribe('order.created', async (event) => {
  try {
    // Validate event data
    if (!event.data || !event.data.id) {
      throw new ValidationError('INVALID_ORDER_DATA', 'Order data is missing required fields');
    }
    
    // Process event
    await processOrder(event.data);
    
    // Record metric
    this.recordMetric('orders.processed', 1, {
      orderId: event.data.id
    });
  } catch (error) {
    // Handle error
    await this.handleError(error, {
      event,
      handler: 'processOrderCreated'
    });
  }
});
```

### 4. Subscription Management

Manage subscriptions properly:

- Set up handlers in module initialization
- Clean up subscriptions on shutdown
- Store subscription IDs for later cleanup
- Use appropriate pattern matching
- Avoid wildcard subscriptions for performance-critical code

Example:
```javascript
class OrderModule extends CoreModule {
  constructor(deps) {
    super(deps);
    this.subscriptions = [];
  }
  
  async setupEventHandlers() {
    const eventBus = this.deps.eventBusSystem.getEventBus();
    
    // Store subscription IDs
    this.subscriptions.push(
      eventBus.subscribe('order.created', this.handleOrderCreated.bind(this)),
      eventBus.subscribe('payment.completed', this.handlePaymentCompleted.bind(this)),
      eventBus.subscribe('shipping.status.*', this.handleShippingUpdates.bind(this))
    );
  }
  
  async onShutdown() {
    // Clean up subscriptions
    const eventBus = this.deps.eventBusSystem.getEventBus();
    for (const subId of this.subscriptions) {
      eventBus.unsubscribe(subId);
    }
    this.subscriptions = [];
  }
}
```

### 5. Error Handling

Use specialized EventError for event-related errors:

```javascript
// Throwing specific event errors
if (!pattern || typeof pattern !== 'string') {
  throw new EventError(
    ErrorCodes.EVENT.INVALID_PATTERN,
    'Event pattern must be a non-empty string',
    { providedPattern: pattern }
  );
}

// Catching and wrapping errors
try {
  await this.eventBus.emit('user.created', userData);
} catch (error) {
  // Handle error and wrap if it's not already an EventError
  if (!(error instanceof EventError)) {
    throw new EventError(
      ErrorCodes.EVENT.EMISSION_FAILED,
      'Failed to emit user.created event',
      { userId: userData.id },
      { cause: error }
    );
  }
  throw error;
}
```

## Using EventBus in Modules

### Module Access to EventBus

Modules should access the EventBus through the EventBusSystem:

```javascript
class BusinessModule extends CoreModule {
  constructor(deps) {
    super(deps);
    // Get eventBus from eventBusSystem
    this.eventBus = deps.eventBusSystem.getEventBus();
  }
}
```

### Setting Up Event Handlers

Implement the `setupEventHandlers` method to set up event handlers:

```javascript
class UserModule extends CoreModule {
  async setupEventHandlers() {
    // Get eventBus from eventBusSystem
    const eventBus = this.deps.eventBusSystem.getEventBus();
    
    // Store subscription IDs for cleanup
    this.subscriptions = [
      // Handle user events
      eventBus.subscribe('user.created', this.handleUserCreated.bind(this)),
      eventBus.subscribe('user.updated', this.handleUserUpdated.bind(this)),
      eventBus.subscribe('user.deleted', this.handleUserDeleted.bind(this)),
      
      // Handle related events
      eventBus.subscribe('auth.login', this.handleUserLogin.bind(this)),
      eventBus.subscribe('auth.logout', this.handleUserLogout.bind(this))
    ];
  }
  
  // Event handlers
  async handleUserCreated(event) {
    try {
      const userData = event.data;
      // Process the user creation...
      await this.db.createUserProfile(userData);
      
      // Emit consequent events
      await this.eventBus.emit('profile.created', {
        userId: userData.id,
        profile: { /* profile data */ }
      });
    } catch (error) {
      await this.handleError(error, {
        event,
        handler: 'handleUserCreated'
      });
    }
  }
  
  // More handlers...
}
```

### Cleaning Up Subscriptions

Clean up subscriptions in the `onShutdown` method:

```javascript
class UserModule extends CoreModule {
  // Other methods...
  
  async onShutdown() {
    // Clean up subscriptions
    if (this.eventBus) {
      for (const subId of this.subscriptions) {
        this.eventBus.unsubscribe(subId);
      }
    }
    this.subscriptions = [];
  }
}
```

### Complete Module Example

A complete example of a module using the EventBus:

```javascript
import { CoreModule } from '../core/module/Module.js';
import { ValidationError, EventError, ErrorCodes } from '../core/errors/index.js';

export class UserModule extends CoreModule {
  static dependencies = ['errorSystem', 'eventBusSystem', 'config', 'database'];
  static version = '1.0.0';
  
  constructor(deps) {
    super(deps);
    this.db = deps.database;
    this.subscriptions = [];
    this.userCache = new Map();
  }
  
  async onConfigure() {
    // Initialize cache settings
    this.cacheEnabled = this.config.userCache?.enabled || true;
    this.cacheTTL = this.config.userCache?.ttl || 3600000; // 1 hour
  }
  
  async setupEventHandlers() {
    const eventBus = this.deps.eventBusSystem.getEventBus();
    
    this.subscriptions = [
      eventBus.subscribe('user.created', this.handleUserCreated.bind(this)),
      eventBus.subscribe('user.updated', this.handleUserUpdated.bind(this)),
      eventBus.subscribe('user.deleted', this.handleUserDeleted.bind(this)),
      eventBus.subscribe('cache.clear', this.handleCacheClear.bind(this))
    ];
  }
  
  async onSetupHealthChecks() {
    // Register user cache health check
    this.registerHealthCheck('userCache', async () => {
      return {
        status: 'healthy',
        size: this.userCache.size,
        enabled: this.cacheEnabled
      };
    });
  }
  
  // Business methods
  async createUser(userData) {
    try {
      // Validate user data
      if (!userData.email) {
        throw new ValidationError('MISSING_EMAIL', 'Email is required');
      }
      
      // Create user in database
      const user = await this.db.users.create(userData);
      
      // Update cache
      if (this.cacheEnabled) {
        this.userCache.set(user.id, {
          data: user,
          expires: Date.now() + this.cacheTTL
        });
      }
      
      // Emit event
      try {
        await this.eventBus.emit('user.created', user);
      } catch (eventError) {
        // Log but don't fail the operation
        await this.handleError(eventError, {
          method: 'createUser',
          event: 'user.created',
          userId: user.id
        });
      }
      
      // Record metric
      this.recordMetric('users.created', 1);
      
      return user;
    } catch (error) {
      await this.handleError(error, {
        method: 'createUser',
        userData
      });
      throw error;
    }
  }
  
  // Event handlers
  async handleUserCreated(event) {
    try {
      const user = event.data;
      
      // Update cache if event came from another instance
      if (this.cacheEnabled && event.metadata?.source !== this.instanceId) {
        this.userCache.set(user.id, {
          data: user,
          expires: Date.now() + this.cacheTTL
        });
      }
      
      // Perform additional processing
      await this.sendWelcomeEmail(user);
    } catch (error) {
      await this.handleError(error, {
        event,
        handler: 'handleUserCreated'
      });
    }
  }
  
  async handleUserUpdated(event) {
    try {
      const user = event.data;
      
      // Update cache
      if (this.cacheEnabled) {
        this.userCache.set(user.id, {
          data: user,
          expires: Date.now() + this.cacheTTL
        });
      }
    } catch (error) {
      await this.handleError(error, {
        event,
        handler: 'handleUserUpdated'
      });
    }
  }
  
  async handleUserDeleted(event) {
    try {
      const { userId } = event.data;
      
      // Remove from cache
      if (this.cacheEnabled) {
        this.userCache.delete(userId);
      }
    } catch (error) {
      await this.handleError(error, {
        event,
        handler: 'handleUserDeleted'
      });
    }
  }
  
  async handleCacheClear(event) {
    try {
      if (event.data.target === 'all' || event.data.target === 'users') {
        this.userCache.clear();
        this.recordMetric('cache.cleared', 1, { target: 'users' });
      }
    } catch (error) {
      await this.handleError(error, {
        event,
        handler: 'handleCacheClear'
      });
    }
  }
  
  async onShutdown() {
    // Clean up subscriptions
    if (this.eventBus) {
      for (const subId of this.subscriptions) {
        this.eventBus.unsubscribe(subId);
      }
    }
    
    // Clear cache
    this.userCache.clear();
  }
}
```

## Troubleshooting

### Common Issues

1. **Event Bus Not Initialized**
   - **Symptom**: `EVENT_NOT_INITIALIZED` error when trying to get or use EventBus
   - **Solution**: Ensure EventBusSystem is initialized before use
   ```javascript
   // Check initialization
   if (!this.initialized) {
     throw new EventError(
       ErrorCodes.EVENT.NOT_INITIALIZED,
       'EventBusSystem is not initialized'
     );
   }
   ```

2. **Missing Dependencies**
   - **Symptom**: `EVENT_MISSING_DEPENDENCIES` error during initialization
   - **Solution**: Ensure all required dependencies are provided
   ```javascript
   // Validate dependencies
   const missing = this.constructor.dependencies.filter(
     dep => !this.deps[dep]
   );

   if (missing.length > 0) {
     throw new EventError(
       ErrorCodes.EVENT.MISSING_DEPENDENCIES,
       `Missing required dependencies: ${missing.join(', ')}`
     );
   }
   ```

3. **Event Handler Errors**
   - **Symptom**: `EVENT_HANDLER_ERROR` during event processing
   - **Solution**: Always use try/catch in handlers
   ```javascript
   try {
     await handler(event);
   } catch (error) {
     await this.handleError(error, {
       event,
       handler: handler.name
     });
   }
   ```

4. **Events Not Received**
   - **Symptom**: Event handlers not being triggered
   - **Solution**: Check event names, patterns, and subscription setup
   ```javascript
   // Debug event subscriptions
   console.log('Subscriptions:', Array.from(eventBus.subscriptions.values()));
   
   // Add debug listener
   eventBus.subscribe('*', (event) => {
     console.log('Event received:', event.name, event);
   });
   ```

5. **Memory Leaks**
   - **Symptom**: Increasing memory usage over time
   - **Solution**: Ensure proper cleanup of subscriptions and event history
   ```javascript
   // Clean up subscriptions
   for (const subId of this.subscriptions) {
     eventBus.unsubscribe(subId);
   }
   
   // Limit event history size
   if (history.length > this.maxHistorySize) {
     history.pop(); // Remove oldest events
   }
   ```

### Debugging Techniques

1. **Enable Event Logging**
   ```javascript
   // Add a global event listener
   eventBus.subscribe('*', (event) => {
     console.log(`[${new Date().toISOString()}] Event:`, event.name, event);
   });
   ```

2. **Check Event History**
   ```javascript
   // Check history for a specific event
   const history = eventBus.getHistory('user.created');
   console.log('Event history:', history);
   
   // Check all event history
   const allHistory = eventBus.getAllHistory();
   console.log('All event history:', allHistory);
   ```

3. **Monitor Health**
   ```javascript
   // Check health status
   const health = await eventBus.checkHealth();
   console.log('EventBus health:', JSON.stringify(health, null, 2));
   ```

4. **Inspect Subscriptions**
   ```javascript
   // Log all subscriptions
   const subscriptions = Array.from(eventBus.subscriptions.values());
   console.log('Active subscriptions:', subscriptions);
   ```

5. **Check Queues**
   ```javascript
   // Check queue sizes
   const queueSizes = {};
   for (const [name, queue] of eventBus.queues.entries()) {
     queueSizes[name] = queue.length;
   }
   console.log('Queue sizes:', queueSizes);
   ```

6. **Monitor System Status**
   ```javascript
   // Check system status
   const status = eventBusSystem.getStatus();
   console.log('System status:', JSON.stringify(status, null, 2));
   ```

7. **Track Metrics**
   ```javascript
   // Check all system metrics
   const metrics = eventBusSystem.getMetrics();
   console.log('System metrics:', metrics);
   ```

### Common Error Codes

- `EVENT_NOT_INITIALIZED`: EventBus or EventBusSystem is not initialized
- `EVENT_ALREADY_INITIALIZED`: EventBus or EventBusSystem is already initialized
- `EVENT_MISSING_DEPENDENCIES`: Required dependencies are missing
- `EVENT_INVALID_DEPENDENCY`: Dependency missing required interface
- `EVENT_INVALID_HANDLER`: Invalid handler function provided
- `EVENT_INVALID_PATTERN`: Invalid event pattern format
- `EVENT_INVALID_EVENT_NAME`: Invalid event name format
- `EVENT_SUBSCRIPTION_FAILED`: Failed to create subscription
- `EVENT_EMISSION_FAILED`: Failed to emit event
- `EVENT_HANDLER_NOT_FOUND`: Specified handler not found
- `EVENT_HANDLER_ERROR`: Error occurred in event handler
- `EVENT_QUEUE_PROCESSING_FAILED`: Failed to process event queue
- `EVENT_INITIALIZATION_FAILED`: Failed to initialize system
- `EVENT_SHUTDOWN_FAILED`: Failed to shutdown system

## Areas for Improvement

1. **Advanced Event Routing**:
   - Implement topic-based routing with hierarchical topics
   - Add support for content-based routing (filtering events based on content)
   - Create routing rules for complex event processing
   - Support dynamic route configuration

2. **Event Validation**:
   - Add schema validation for events
   - Implement event versioning and schema evolution
   - Create event format validation
   - Support typed events with runtime validation

3. **Performance Optimization**:
   - Implement batched event processing
   - Add support for worker threads for parallel processing
   - Create optimized subscription matching algorithm
   - Support high-throughput scenarios

4. **Distributed Event Processing**:
   - Add support for distributed event buses across instances
   - Implement consistent event ordering in distributed setups
   - Create cross-service event propagation
   - Support cloud-based event distribution

5. **Event Persistence**:
   - Implement event sourcing capabilities
   - Add durable subscriptions and reliable delivery
   - Create event replay functionality
   - Support event journaling and recovery

6. **Event Observability**:
   - Add comprehensive event tracing
   - Implement causality tracking between events
   - Create visual event flow monitoring
   - Support OpenTelemetry integration

7. **Advanced Pattern Matching**:
   - Implement more sophisticated pattern matching (regex, glob)
   - Add content-based filtering for subscriptions
   - Create complex condition matching for events
   - Support composite event patterns (AND/OR logic)

8. **Security Enhancements**:
   - Add permission-based event publishing and subscription
   - Implement event content encryption
   - Create audit logging for sensitive events
   - Support fine-grained access control


// src/core/module/Module.js

// src/core/module/Module.js
import { EventEmitter } from 'events';
import { CoreEventBus } from '../event/EventBus.js';
import { ModuleError, ValidationError } from '../errors/index.js';

export class CoreModule extends EventEmitter {
  static dependencies = ['errorSystem', 'eventBusSystem', 'config'];
  static version = '1.0.0';
  
  constructor(deps = {}) {
    super();
    this.deps = deps;
    // Get the eventBus from eventBusSystem
    this.eventBus = deps.eventBusSystem?.getEventBus();
    this.initialized = false;
    this.config = deps.config || {};
    
    // Enhanced state tracking
    this.state = {
      status: 'created',
      startTime: null,
      errors: [],
      metrics: new Map(),
      healthChecks: new Map(),
      lastHealthCheck: null
    };

    // Validate dependencies immediately
    this.validateDependencies();
    
    // Set up health check interval
    this.healthCheckInterval = null;
  }

  validateDependencies() {
    // Check required dependencies
    const missing = this.constructor.dependencies.filter(
      dep => !this.deps[dep]
    );

    if (missing.length > 0) {
      throw new ModuleError(
        'MISSING_DEPENDENCIES',
        `Missing required dependencies: ${missing.join(', ')}`
      );
    }

    // Validate eventBusSystem dependency
    if (this.deps.eventBusSystem && typeof this.deps.eventBusSystem.getEventBus !== 'function') {
      throw new ModuleError(
        'INVALID_EVENTBUS_SYSTEM',
        'EventBusSystem missing required method: getEventBus'
      );
    }

    if (this.deps.errorSystem && typeof this.deps.errorSystem.handleError !== 'function') {
      throw new ModuleError(
        'INVALID_ERROR_SYSTEM',
        'ErrorSystem missing required methods'
      );
    }
  }

  async validateConfig() {
    try {
      // Basic config validation
      if (this.config === null || typeof this.config !== 'object') {
        throw new ValidationError(
          'INVALID_CONFIG',
          'Configuration must be an object'
        );
      }

      // Module-specific validation
      await this.onValidateConfig();
      
      return true;
    } catch (error) {
      throw new ModuleError(
        'CONFIG_VALIDATION_FAILED',
        'Failed to validate configuration',
        { originalError: error }
      );
    }
  }

  async initialize() {
    if (this.initialized) {
      throw new ModuleError(
        'ALREADY_INITIALIZED',
        'Module is already initialized'
      );
    }

    try {
      this.state.startTime = Date.now();
      this.state.status = 'initializing';

      // Configuration phase
      await this.validateConfig();
      await this.onConfigure();

      // Setup phase
      await this.setupEventHandlers();
      await this.setupHealthChecks();

      // Initialize phase
      await this.onInitialize();

      // Start health check monitoring
      this.startHealthChecks();
      
      this.initialized = true;
      this.state.status = 'running';

      await this.emit('module:initialized', {
        name: this.constructor.name,
        timestamp: new Date().toISOString()
      });

      return this;

    } catch (error) {
      this.state.status = 'error';
      this.state.errors.push({
        timestamp: new Date().toISOString(),
        error: error.message
      });

      throw new ModuleError(
        'INITIALIZATION_FAILED',
        'Failed to initialize module',
        { originalError: error }
      );
    }
  }

  async setupHealthChecks() {
    // Register default health checks
    this.registerHealthCheck('state', async () => {
      return {
        status: this.state.status === 'running' ? 'healthy' : 'unhealthy',
        uptime: Date.now() - this.state.startTime,
        errorCount: this.state.errors.length
      };
    });

    // Allow modules to add their own health checks
    await this.onSetupHealthChecks();
  }

  registerHealthCheck(name, checkFn) {
    if (typeof checkFn !== 'function') {
      throw new ModuleError(
        'INVALID_HEALTH_CHECK',
        `Health check ${name} must be a function`
      );
    }
    this.state.healthChecks.set(name, checkFn);
  }

  startHealthChecks() {
    // Run health checks every 30 seconds by default
    this.healthCheckInterval = setInterval(async () => {
      try {
        const health = await this.checkHealth();
        this.state.lastHealthCheck = health;
        
        if (health.status !== 'healthy') {
          await this.handleError(new ModuleError(
            'HEALTH_CHECK_FAILED',
            'Module health check failed',
            { health }
          ));
        }
      } catch (error) {
        await this.handleError(error);
      }
    }, 30000);
  }

  async checkHealth() {
    const results = {};
    let overallStatus = 'healthy';

    for (const [name, checkFn] of this.state.healthChecks) {
      try {
        results[name] = await checkFn();
        if (results[name].status !== 'healthy') {
          overallStatus = 'unhealthy';
        }
      } catch (error) {
        results[name] = {
          status: 'error',
          error: error.message
        };
        overallStatus = 'unhealthy';
      }
    }

    return {
      name: this.constructor.name,
      version: this.constructor.version,
      status: overallStatus,
      timestamp: new Date().toISOString(),
      checks: results
    };
  }

  async handleError(error, context = {}) {
    const safeContext = context || {};

    // Add error to state
    this.state.errors.push({
      timestamp: new Date().toISOString(),
      error: error.message,
      context: safeContext
    });

    // Trim error history
    if (this.state.errors.length > 100) {
      this.state.errors.shift();
    }

    // Forward to error system
    if (this.deps.errorSystem) {
      try {
        await this.deps.errorSystem.handleError(error, {
          module: this.constructor.name,
          ...safeContext
        });
      } catch (handlerError) {
        // Log error handling failure
        console.error('Error in error handling:', handlerError);
      }
    }

    // Emit error event
    await this.emit('module:error', {
      module: this.constructor.name,
      error,
      context: safeContext
    });

    return this;
  }

  async emit(eventName, ...args) {
    // Emit through local EventEmitter
    const localEmitResult = super.emit(eventName, ...args);

    // Broadcast through eventBus if available
    if (this.eventBus?.emit) {
      try {
        await this.eventBus.emit(eventName, ...args);
      } catch (error) {
        await this.handleError(error, {
          event: eventName,
          args
        });
      }
    }

    return localEmitResult;
  }

  async shutdown() {
    try {
      if (!this.initialized) {
        return this;
      }

      this.state.status = 'shutting_down';
      
      // Stop health checks
      if (this.healthCheckInterval) {
        clearInterval(this.healthCheckInterval);
        this.healthCheckInterval = null;
      }

      // Custom shutdown logic
      await this.onShutdown();
      
      // Reset state
      this.initialized = false;
      this.state.status = 'shutdown';
      this.state.startTime = null;
      
      await this.emit('module:shutdown', {
        name: this.constructor.name,
        timestamp: new Date().toISOString()
      });

      return this;
    } catch (error) {
      this.state.status = 'error';
      this.state.errors.push({
        timestamp: new Date().toISOString(),
        error: error.message,
        context: { phase: 'shutdown' }
      });

      throw new ModuleError(
        'SHUTDOWN_FAILED',
        'Failed to shutdown module',
        { originalError: error }
      );
    }
  }

  // Lifecycle hooks for derived classes
  async onValidateConfig() {
    // Override in derived classes
    return true;
  }

  async onConfigure() {
    // Override in derived classes
    return Promise.resolve();
  }

  async setupEventHandlers() {
    // Override in derived classes
    return Promise.resolve();
  }

  async onSetupHealthChecks() {
    // Override in derived classes
    return Promise.resolve();
  }

  async onInitialize() {
    // Override in derived classes
    return Promise.resolve();
  }

  async onShutdown() {
    // Override in derived classes
    return Promise.resolve();
  }

  // Metrics tracking
  recordMetric(name, value, tags = {}) {
    this.state.metrics.set(name, {
      value,
      timestamp: Date.now(),
      tags
    });
  }
}

export function createModule(deps = {}) {
  const defaultDeps = {
    errorSystem: {
      handleError: async () => {} // No-op error handler
    },
    eventBusSystem: {
      getEventBus: () => new CoreEventBus({ // Use CoreEventBus instead of EventEmitter
        errorSystem: deps.errorSystem,
        config: deps.config
      })
    },
    config: {} // Empty configuration object
  };

  const mergedDeps = {
    ...defaultDeps,
    ...deps
  };

  return new CoreModule(mergedDeps);
}

export default {
  CoreModule,
  createModule
};


// src/core/module/ModuleSystem.js

// src/core/module/ModuleSystem.js
import { EventEmitter } from 'events';
import { CoreModule } from './Module.js';
import { ModuleError, ValidationError } from '../errors/index.js';

export class ModuleSystem extends EventEmitter {
  static dependencies = ['errorSystem', 'eventBusSystem', 'config'];

  constructor(deps) {
    super();
    this.deps = deps;
    this.modules = new Map();
    this.initialized = false;
    // Get eventBus from eventBusSystem
    this.eventBus = deps.eventBusSystem?.getEventBus();
    this.state = {
      status: 'created',
      startTime: null,
      errors: [],
      metrics: new Map(),
      moduleHealth: new Map(),
      healthCheckIntervals: new Map() // Track intervals for proper cleanup
    };

    // Validate dependencies
    this.validateDependencies();
  }

  validateDependencies() {
    const missing = this.constructor.dependencies.filter(
      dep => !this.deps[dep]
    );

    if (missing.length > 0) {
      throw new ModuleError(
        'MISSING_DEPENDENCIES',
        `Missing required dependencies: ${missing.join(', ')}`
      );
    }

    // Validate eventBusSystem
    if (!this.deps.eventBusSystem?.getEventBus) {
      throw new ModuleError(
        'INVALID_EVENTBUS_SYSTEM',
        'EventBusSystem missing required methods'
      );
    }

    if (!this.deps.errorSystem?.handleError) {
      throw new ModuleError(
        'INVALID_ERROR_SYSTEM',
        'ErrorSystem missing required methods'
      );
    }
  }

  async emit(eventName, ...args) {
    // Local EventEmitter emission
    const localEmitResult = super.emit(eventName, ...args);
    
    // Use eventBus for global events if available
    if (this.eventBus?.emit) {
      try {
        await this.eventBus.emit(eventName, ...args);
      } catch (error) {
        await this.handleModuleError('ModuleSystem', error);
      }
    }
    
    return localEmitResult;
  }

  async register(name, ModuleClass, config = {}) {
    if (!(ModuleClass.prototype instanceof CoreModule)) {
      throw new ValidationError(
        'INVALID_MODULE',
        'Module must extend CoreModule'
      );
    }

    if (this.modules.has(name)) {
      throw new ModuleError(
        'DUPLICATE_MODULE',
        `Module ${name} is already registered`
      );
    }

    try {
      // Create module instance with dependencies
      const module = new ModuleClass({
        ...this.deps,
        config: {
          ...this.deps.config?.[name],
          ...config
        }
      });

      this.modules.set(name, module);

      // Setup health check listener
      module.on('module:error', async (error) => {
        await this.handleModuleError(name, error);
      });

      await this.emit('module:registered', {
        name,
        timestamp: new Date().toISOString()
      });

      return module;
    } catch (error) {
      throw new ModuleError(
        'REGISTRATION_FAILED',
        `Failed to register module ${name}`,
        { originalError: error }
      );
    }
  }

  async unregister(name) {
    const module = this.modules.get(name);
    if (!module) return;

    try {
      if (module.initialized) {
        await module.shutdown();
      }
      
      this.modules.delete(name);
      
      await this.emit('module:unregistered', {
        name,
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      throw new ModuleError(
        'UNREGISTER_FAILED',
        `Failed to unregister module ${name}`,
        { originalError: error }
      );
    }
  }

  async resolve(name) {
    const module = this.modules.get(name);
    if (!module) {
      throw new ModuleError(
        'MODULE_NOT_FOUND',
        `Module ${name} is not registered`
      );
    }
    return module;
  }

  async initialize() {
    if (this.initialized) {
      throw new ModuleError(
        'ALREADY_INITIALIZED',
        'ModuleSystem is already initialized'
      );
    }

    try {
      this.state.startTime = Date.now();
      this.state.status = 'initializing';

      // Initialize modules in dependency order
      const initOrder = this.resolveDependencyOrder();
      
      for (const name of initOrder) {
        const module = this.modules.get(name);
        await module.initialize();
        
        // Start monitoring module health
        await this.startModuleHealthMonitoring(name);
      }

      this.initialized = true;
      this.state.status = 'running';

      await this.emit('system:initialized', {
        timestamp: new Date().toISOString(),
        modules: Array.from(this.modules.keys())
      });

    } catch (error) {
      this.state.status = 'error';
      throw new ModuleError(
        'INITIALIZATION_FAILED',
        'Failed to initialize module system',
        { originalError: error }
      );
    }
  }

  resolveDependencyOrder() {
    const visited = new Set();
    const visiting = new Set();
    const order = [];

    const visit = (name) => {
      if (visited.has(name)) return;
      if (visiting.has(name)) {
        throw new ModuleError(
          'CIRCULAR_DEPENDENCY',
          `Circular dependency detected for module: ${name}`
        );
      }

      visiting.add(name);

      const module = this.modules.get(name);
      const deps = module.constructor.dependencies || [];

      for (const dep of deps) {
        if (!this.modules.has(dep)) {
          throw new ModuleError(
            'MISSING_DEPENDENCY',
            `Module ${name} requires missing module: ${dep}`
          );
        }
        visit(dep);
      }

      visiting.delete(name);
      visited.add(name);
      order.push(name);
    };

    for (const name of this.modules.keys()) {
      visit(name);
    }

    return order;
  }

  async startModuleHealthMonitoring(name) {
    const module = this.modules.get(name);
    if (!module) return;

    // Clear any existing interval
    if (this.state.healthCheckIntervals.has(name)) {
      clearInterval(this.state.healthCheckIntervals.get(name));
    }

    // Monitor module health status
    const intervalId = setInterval(async () => {
      try {
        const health = await module.checkHealth();
        this.state.moduleHealth.set(name, health);

        if (health.status !== 'healthy') {
          await this.handleModuleError(name, new ModuleError(
            'UNHEALTHY_MODULE',
            `Module ${name} is unhealthy`,
            { health }
          ));
        }
      } catch (error) {
        await this.handleModuleError(name, error);
      }
    }, 60000); // Check every minute

    // Track the interval for proper cleanup
    this.state.healthCheckIntervals.set(name, intervalId);
  }

  // async handleModuleError(moduleName, error) {
  //   this.state.errors.push({
  //     timestamp: new Date().toISOString(),
  //     module: moduleName,
  //     error: error.message
  //   });

  //   // Trim error history
  //   if (this.state.errors.length > 100) {
  //     this.state.errors.shift();
  //   }

  //   // Forward to error system
  //   try {
  //     if (this.deps.errorSystem?.handleError) {
  //       await this.deps.errorSystem.handleError(error, {
  //         source: 'ModuleSystem',
  //         module: moduleName
  //       });
  //     }
  //   } catch (handlerError) {
  //     // Log the error from the error system but don't rethrow
  //     console.error('Error in error handling:', handlerError);
  //   }
  //   await this.emit('module:error', {
  //     module: moduleName,
  //     error,
  //     timestamp: new Date().toISOString()
  //   });
  // }

  async handleModuleError(moduleName, error) {
    this.state.errors.push({
      timestamp: new Date().toISOString(),
      module: moduleName,
      error: error.message
    });
  
    // Trim error history
    if (this.state.errors.length > 100) {
      this.state.errors.shift();
    }
  
    // Defensive error handling for error system
    if (this.deps.errorSystem && typeof this.deps.errorSystem.handleError === 'function') {
      try {
        // Carefully forward error to error system with context
        await this.deps.errorSystem.handleError(error, {
          source: 'ModuleSystem',
          module: moduleName,
          timestamp: new Date().toISOString()
        });
      } catch (handlerError) {
        // Fallback logging mechanism
        const fallbackErrorLog = {
          timestamp: new Date().toISOString(),
          source: 'ModuleSystem',
          originalError: error.message,
          handlerError: handlerError.message,
          module: moduleName
        };
  
        // Use a robust logging mechanism
        if (typeof console.error === 'function') {
          console.error('Error System Failure:', JSON.stringify(fallbackErrorLog, null, 2));
        }
  
        // Optional: Add to local error tracking if error system fails
        this.state.errors.push({
          ...fallbackErrorLog,
          type: 'HANDLER_FAILURE'
        });
      }
    }
  
    // Emit error event regardless of error system status
    await this.emit('module:error', {
      module: moduleName,
      error,
      timestamp: new Date().toISOString()
    });
  }

  async getSystemHealth() {
    const moduleHealth = {};
    let systemStatus = 'healthy';

    for (const [name, module] of this.modules) {
      try {
        const health = await module.checkHealth();
        moduleHealth[name] = health;
        
        if (health.status !== 'healthy') {
          systemStatus = 'degraded';
        }
      } catch (error) {
        moduleHealth[name] = {
          status: 'error',
          error: error.message
        };
        systemStatus = 'unhealthy';
      }
    }

    return {
      status: systemStatus,
      timestamp: new Date().toISOString(),
      uptime: Date.now() - this.state.startTime,
      modules: moduleHealth,
      errorCount: this.state.errors.length
    };
  }

  async shutdown() {
    if (!this.initialized) return;

    try {
      this.state.status = 'shutting_down';

      // Clear all health check intervals
      for (const [name, intervalId] of this.state.healthCheckIntervals) {
        clearInterval(intervalId);
      }
      this.state.healthCheckIntervals.clear();

      // Shutdown modules in reverse dependency order
      const shutdownOrder = this.resolveDependencyOrder().reverse();

      for (const name of shutdownOrder) {
        const module = this.modules.get(name);
        await module.shutdown();
      }

      this.modules.clear();
      this.initialized = false;
      this.state.status = 'shutdown';

      await this.emit('system:shutdown', {
        timestamp: new Date().toISOString()
      });

    } catch (error) {
      this.state.status = 'error';
      throw new ModuleError(
        'SHUTDOWN_FAILED',
        'Failed to shutdown module system',
        { originalError: error }
      );
    }
  }
}

export function createModuleSystem(deps = {}) {
  const defaultDeps = {
    errorSystem: {
      handleError: async () => {} // No-op error handler
    },
    eventBusSystem: {
      getEventBus: () => new EventEmitter() // Default eventBus provider
    },
    config: {} // Empty configuration object
  };

  return new ModuleSystem({
    ...defaultDeps,
    ...deps
  });
}

export default {
  ModuleSystem,
  createModuleSystem
};


// src/core/module/module-system-docs.md

# Module System Documentation

## Table of Contents
1. [Overview](#overview)
2. [Purpose](#purpose)
3. [System Architecture](#system-architecture)
4. [Core Components](#core-components)
5. [Module Lifecycle](#module-lifecycle)
6. [Dependency Management](#dependency-management)
7. [State Management](#state-management)
8. [Health Monitoring](#health-monitoring)
9. [Error Handling](#error-handling)
10. [Event System Integration](#event-system-integration)
11. [Module Implementation](#module-implementation)
12. [Module Registration](#module-registration)
13. [Testing Strategy](#testing-strategy)
14. [Best Practices](#best-practices)
15. [Extending the System](#extending-the-system)
16. [Areas for Improvement](#areas-for-improvement)

## Overview

The Module System provides a standardized approach to creating, managing, and connecting application components. It enforces consistent module lifecycle management, dependency injection, health monitoring, event communication, and error handling. This system allows for organizing business logic into cohesive, reusable modules that can be independently developed, tested, and composed.

## Purpose

The primary goals of the Module System are to:
- Provide a consistent structure for business logic
- Enforce proper lifecycle management
- Enable loose coupling through dependency injection
- Facilitate module-to-module communication
- Support comprehensive health monitoring
- Establish standardized error handling
- Allow for independent testing of modules
- Promote code organization and maintainability

## System Architecture

### High-Level Architecture

```mermaid
graph TB
    ModuleSystem --> |Manages| CoreModule
    ModuleSystem --> |Resolves| ModuleDependencies
    ModuleSystem --> |Monitors| ModuleHealth
    
    CoreModule --> |Extended by| BusinessModules
    BusinessModules --> UserModule
    BusinessModules --> InventoryModule
    BusinessModules --> AuthModule
    
    CoreContainer --> |Resolves| ModuleSystem
    EventBusSystem --> |Enables Communication| CoreModule
    ErrorSystem --> |Handles Errors| CoreModule
```

### Layer Structure

The TSMIS architecture is built on three main layers:
1. **Core Systems** - Fundamental infrastructure (Container, ErrorSystem, EventBusSystem, ModuleSystem)
2. **Service Systems** - Common service functionality 
3. **Business Modules** - Business domain logic

## Core Components

### ModuleSystem

The `ModuleSystem` class is responsible for managing modules:

```javascript
class ModuleSystem extends EventEmitter {
  static dependencies = ['errorSystem', 'eventBusSystem', 'config'];

  constructor(deps) {
    super();
    this.deps = deps;
    this.modules = new Map();
    this.initialized = false;
    this.eventBus = deps.eventBusSystem?.getEventBus();
    this.state = {
      status: 'created',
      startTime: null,
      errors: [],
      metrics: new Map(),
      moduleHealth: new Map(),
      healthCheckIntervals: new Map()
    };
  }

  // Key methods
  async register(name, ModuleClass, config = {}) { /* ... */ }
  async resolve(name) { /* ... */ }
  async unregister(name) { /* ... */ }
  async initialize() { /* ... */ }
  async shutdown() { /* ... */ }
  async handleModuleError(moduleName, error) { /* ... */ }
  async getSystemHealth() { /* ... */ }
  resolveDependencyOrder() { /* ... */ }
}
```

### CoreModule

The `CoreModule` class serves as the base class for all modules:

```javascript
class CoreModule extends EventEmitter {
  static dependencies = ['errorSystem', 'eventBusSystem', 'config'];
  static version = '1.0.0';

  constructor(deps = {}) {
    super();
    this.deps = deps;
    this.eventBus = deps.eventBusSystem?.getEventBus();
    this.initialized = false;
    this.config = deps.config || {};
    this.state = {
      status: 'created',
      startTime: null,
      errors: [],
      metrics: new Map(),
      healthChecks: new Map(),
      lastHealthCheck: null
    };
  }

  // Lifecycle methods
  async validateDependencies() { /* ... */ }
  async validateConfig() { /* ... */ }
  async initialize() { /* ... */ }
  async setupHealthChecks() { /* ... */ }
  async handleError(error, context = {}) { /* ... */ }
  async emit(eventName, ...args) { /* ... */ }
  async shutdown() { /* ... */ }

  // Health monitoring
  registerHealthCheck(name, checkFn) { /* ... */ }
  startHealthChecks() { /* ... */ }
  async checkHealth() { /* ... */ }

  // Metrics recording
  recordMetric(name, value, tags = {}) { /* ... */ }

  // Lifecycle hooks for derived classes
  async onValidateConfig() { /* ... */ }
  async onConfigure() { /* ... */ }
  async setupEventHandlers() { /* ... */ }
  async onSetupHealthChecks() { /* ... */ }
  async onInitialize() { /* ... */ }
  async onShutdown() { /* ... */ }
}
```

## Module Lifecycle

The Module System enforces a consistent lifecycle for all modules:

### Lifecycle Phases

1. **Creation**
   - Module instance is created
   - Dependencies are injected
   - Initial validation

2. **Configuration**
   - Module configuration is validated
   - Module-specific configuration is applied
   - Resources are prepared

3. **Setup**
   - Event handlers are registered
   - Health checks are configured
   - Resources are connected

4. **Initialization**
   - Module-specific initialization
   - State initialization
   - Ready for operation

5. **Operation**
   - Module is fully operational
   - Event handling and processing
   - Regular health monitoring

6. **Shutdown**
   - Resources are released
   - Event handlers are unregistered
   - Clean termination

### Lifecycle Flow

```mermaid
stateDiagram-v2
    [*] --> created: Module Created
    created --> initializing: initialize()
    initializing --> configuring: validateConfig()
    configuring --> configuring: onConfigure()
    configuring --> setup: Setup Phase
    setup --> setup: setupEventHandlers()
    setup --> setup: setupHealthChecks()
    setup --> initializing_module: onInitialize()
    initializing_module --> running: Initialization Complete
    running --> shutting_down: shutdown()
    shutting_down --> shutting_down: onShutdown()
    shutting_down --> shutdown: Shutdown Complete
    shutdown --> [*]
    
    created --> error: Error
    initializing --> error: Error
    configuring --> error: Error
    setup --> error: Error
    initializing_module --> error: Error
    running --> error: Error
    shutting_down --> error: Error
```

### Lifecycle Method Sequence

1. **Module.validateDependencies()** - Validates required dependencies
2. **Module.validateConfig()** - Validates module configuration
3. **Module.onValidateConfig()** - Custom configuration validation
4. **Module.onConfigure()** - Apply configuration and setup module state
5. **Module.setupEventHandlers()** - Register event handlers
6. **Module.setupHealthChecks()** - Configure health checks
7. **Module.onSetupHealthChecks()** - Module-specific health checks
8. **Module.onInitialize()** - Complete module initialization
9. **Module.onShutdown()** - Custom shutdown logic

## Dependency Management

### Module Dependencies

Modules declare their dependencies using the static `dependencies` property:

```javascript
class UserModule extends CoreModule {
  static dependencies = ['errorSystem', 'eventBusSystem', 'config', 'database', 'auth'];
  
  constructor(deps) {
    super(deps);
    this.database = deps.database;
    this.auth = deps.auth;
  }
}
```

### Dependency Resolution

The `ModuleSystem` resolves dependencies between modules:

```javascript
resolveDependencyOrder() {
  const visited = new Set();
  const visiting = new Set();
  const order = [];

  const visit = (name) => {
    if (visited.has(name)) return;
    if (visiting.has(name)) {
      throw new ModuleError(
        'CIRCULAR_DEPENDENCY',
        `Circular dependency detected for module: ${name}`
      );
    }

    visiting.add(name);

    const module = this.modules.get(name);
    const deps = module.constructor.dependencies || [];

    for (const dep of deps) {
      if (!this.modules.has(dep)) {
        throw new ModuleError(
          'MISSING_DEPENDENCY',
          `Module ${name} requires missing module: ${dep}`
        );
      }
      visit(dep);
    }

    visiting.delete(name);
    visited.add(name);
    order.push(name);
  };

  for (const name of this.modules.keys()) {
    visit(name);
  }

  return order;
}
```

### Dependency Validation

Modules validate their dependencies during construction:

```javascript
validateDependencies() {
  // Check required dependencies
  const missing = this.constructor.dependencies.filter(
    dep => !this.deps[dep]
  );

  if (missing.length > 0) {
    throw new ModuleError(
      'MISSING_DEPENDENCIES',
      `Missing required dependencies: ${missing.join(', ')}`
    );
  }

  // Validate eventBusSystem dependency
  if (this.deps.eventBusSystem && typeof this.deps.eventBusSystem.getEventBus !== 'function') {
    throw new ModuleError(
      'INVALID_EVENTBUS_SYSTEM',
      'EventBusSystem missing required method: getEventBus'
    );
  }

  if (this.deps.errorSystem && typeof this.deps.errorSystem.handleError !== 'function') {
    throw new ModuleError(
      'INVALID_ERROR_SYSTEM',
      'ErrorSystem missing required methods'
    );
  }
}
```

## State Management

### Module States

Modules transition through the following states during their lifecycle:

- **created**: Initial module state after instantiation
- **initializing**: During initialization process
- **running**: Module is active and operational
- **shutting_down**: During shutdown process
- **shutdown**: Module is inactive
- **error**: Error state when something fails

### State Tracking

The state object stores comprehensive module metadata:

```javascript
this.state = {
  status: 'created',        // Current module state
  startTime: null,          // When module was started
  errors: [],               // Error history
  metrics: new Map(),       // Performance metrics
  healthChecks: new Map(),  // Health check functions
  lastHealthCheck: null     // Last health check result
};
```

### State Transitions

The `ModuleSystem` manages state transitions:

```javascript
async initialize() {
  if (this.initialized) {
    throw new ModuleError(
      'ALREADY_INITIALIZED',
      'Module is already initialized'
    );
  }

  try {
    this.state.startTime = Date.now();
    this.state.status = 'initializing';

    // Configuration phase
    await this.validateConfig();
    await this.onConfigure();

    // Setup phase
    await this.setupEventHandlers();
    await this.setupHealthChecks();

    // Initialize phase
    await this.onInitialize();

    // Start health check monitoring
    this.startHealthChecks();
    
    this.initialized = true;
    this.state.status = 'running';

    await this.emit('module:initialized', {
      name: this.constructor.name,
      timestamp: new Date().toISOString()
    });

    return this;

  } catch (error) {
    this.state.status = 'error';
    this.state.errors.push({
      timestamp: new Date().toISOString(),
      error: error.message
    });

    throw new ModuleError(
      'INITIALIZATION_FAILED',
      'Failed to initialize module',
      { originalError: error }
    );
  }
}
```

## Health Monitoring

### Health Check Registration

Modules register health checks during initialization:

```javascript
async setupHealthChecks() {
  // Register default health checks
  this.registerHealthCheck('state', async () => {
    return {
      status: this.state.status === 'running' ? 'healthy' : 'unhealthy',
      uptime: Date.now() - this.state.startTime,
      errorCount: this.state.errors.length
    };
  });

  // Allow modules to add their own health checks
  await this.onSetupHealthChecks();
}

registerHealthCheck(name, checkFn) {
  if (typeof checkFn !== 'function') {
    throw new ModuleError(
      'INVALID_HEALTH_CHECK',
      `Health check ${name} must be a function`
    );
  }
  this.state.healthChecks.set(name, checkFn);
}
```

### Health Check Execution

The `checkHealth` method runs all registered health checks:

```javascript
async checkHealth() {
  const results = {};
  let overallStatus = 'healthy';

  for (const [name, checkFn] of this.state.healthChecks) {
    try {
      results[name] = await checkFn();
      if (results[name].status !== 'healthy') {
        overallStatus = 'unhealthy';
      }
    } catch (error) {
      results[name] = {
        status: 'error',
        error: error.message
      };
      overallStatus = 'unhealthy';
    }
  }

  return {
    name: this.constructor.name,
    version: this.constructor.version,
    status: overallStatus,
    timestamp: new Date().toISOString(),
    checks: results
  };
}
```

### Health Monitoring

The `ModuleSystem` monitors the health of all modules:

```javascript
async startModuleHealthMonitoring(name) {
  const module = this.modules.get(name);
  if (!module) return;

  // Clear any existing interval
  if (this.state.healthCheckIntervals.has(name)) {
    clearInterval(this.state.healthCheckIntervals.get(name));
  }

  // Monitor module health status
  const intervalId = setInterval(async () => {
    try {
      const health = await module.checkHealth();
      this.state.moduleHealth.set(name, health);

      if (health.status !== 'healthy') {
        await this.handleModuleError(name, new ModuleError(
          'UNHEALTHY_MODULE',
          `Module ${name} is unhealthy`,
          { health }
        ));
      }
    } catch (error) {
      await this.handleModuleError(name, error);
    }
  }, 60000); // Check every minute

  // Track the interval for proper cleanup
  this.state.healthCheckIntervals.set(name, intervalId);
}
```

### System Health Check

The `ModuleSystem` provides a `getSystemHealth` method to check the health of all modules:

```javascript
async getSystemHealth() {
  const moduleHealth = {};
  let systemStatus = 'healthy';

  for (const [name, module] of this.modules) {
    try {
      const health = await module.checkHealth();
      moduleHealth[name] = health;
      
      if (health.status !== 'healthy') {
        systemStatus = 'degraded';
      }
    } catch (error) {
      moduleHealth[name] = {
        status: 'error',
        error: error.message
      };
      systemStatus = 'unhealthy';
    }
  }

  return {
    status: systemStatus,
    timestamp: new Date().toISOString(),
    uptime: Date.now() - this.state.startTime,
    modules: moduleHealth,
    errorCount: this.state.errors.length
  };
}
```

## Error Handling

### Module Error Handling

Each module has an `handleError` method for error processing:

```javascript
async handleError(error, context = {}) {
  const safeContext = context || {};

  // Add error to state
  this.state.errors.push({
    timestamp: new Date().toISOString(),
    error: error.message,
    context: safeContext
  });

  // Trim error history
  if (this.state.errors.length > 100) {
    this.state.errors.shift();
  }

  // Forward to error system
  if (this.deps.errorSystem) {
    try {
      await this.deps.errorSystem.handleError(error, {
        module: this.constructor.name,
        ...safeContext
      });
    } catch (handlerError) {
      // Log error handling failure
      console.error('Error in error handling:', handlerError);
    }
  }

  // Emit error event
  await this.emit('module:error', {
    module: this.constructor.name,
    error,
    context: safeContext
  });

  return this;
}
```

### System-Level Error Handling

The `ModuleSystem` includes special error handling for modules:

```javascript
async handleModuleError(moduleName, error) {
  // Add error to state
  this.state.errors.push({
    timestamp: new Date().toISOString(),
    module: moduleName,
    error: error.message
  });

  // Trim error history
  if (this.state.errors.length > 100) {
    this.state.errors.shift();
  }

  // Forward to error system if available
  if (this.deps.errorSystem) {
    try {
      await this.deps.errorSystem.handleError(error, {
        source: 'ModuleSystem',
        module: moduleName
      });
    } catch (handlerError) {
      // Handle error system failures
      this.state.errors.push({
        timestamp: new Date().toISOString(),
        error: handlerError.message,
        context: { phase: 'error-handling' }
      });
    }
  }

  // Emit error event
  await this.emit('module:error', {
    module: moduleName,
    error,
    timestamp: new Date().toISOString()
  });
}
```

## Event System Integration

### Dual Event Emission

Modules feature dual event emission:

```javascript
async emit(eventName, ...args) {
  // Emit through local EventEmitter
  const localEmitResult = super.emit(eventName, ...args);

  // Broadcast through eventBus if available
  if (this.eventBus?.emit) {
    try {
      await this.eventBus.emit(eventName, ...args);
    } catch (error) {
      await this.handleError(error, {
        event: eventName,
        args
      });
    }
  }

  return localEmitResult;
}
```

### Event Handler Setup

Modules set up event handlers in the `setupEventHandlers` method:

```javascript
async setupEventHandlers() {
  // Get eventBus from eventBusSystem
  const eventBus = this.deps.eventBusSystem.getEventBus();
  
  // Store subscription IDs for cleanup
  this.subscriptions = [
    eventBus.subscribe('user.created', this.handleUserCreated.bind(this)),
    eventBus.subscribe('user.updated', this.handleUserUpdated.bind(this)),
    eventBus.subscribe('user.deleted', this.handleUserDeleted.bind(this))
  ];
}
```

### Event Cleanup

Modules clean up event subscriptions during shutdown:

```javascript
async onShutdown() {
  // Clean up subscriptions
  if (this.eventBus) {
    for (const subId of this.subscriptions) {
      this.eventBus.unsubscribe(subId);
    }
  }
  this.subscriptions = [];
}
```

## Module Implementation

### Basic Module Template

```javascript
import { CoreModule } from '@core/module/Module';
import { ValidationError } from '@core/errors';

export class UserModule extends CoreModule {
  static dependencies = ['errorSystem', 'eventBusSystem', 'config', 'database'];
  static version = '1.0.0';
  
  constructor(deps) {
    super(deps);
    this.db = deps.database;
    this.subscriptions = [];
  }
  
  async onValidateConfig() {
    // Validate required configuration
    if (!this.config.userRoles) {
      throw new ValidationError(
        'MISSING_CONFIG',
        'User roles configuration is required'
      );
    }
    return true;
  }
  
  async onConfigure() {
    // Initialize module state
    this.userRoles = this.config.userRoles;
    this.cacheEnabled = this.config.cache?.enabled || false;
    this.userCache = new Map();
  }
  
  async setupEventHandlers() {
    const eventBus = this.deps.eventBusSystem.getEventBus();
    
    this.subscriptions = [
      eventBus.subscribe('user.created', this.handleUserCreated.bind(this)),
      eventBus.subscribe('user.updated', this.handleUserUpdated.bind(this)),
      eventBus.subscribe('user.deleted', this.handleUserDeleted.bind(this))
    ];
  }
  
  async onSetupHealthChecks() {
    // Register custom health checks
    this.registerHealthCheck('database', async () => {
      const connected = await this.db.checkConnection();
      return {
        status: connected ? 'healthy' : 'unhealthy',
        details: { connected }
      };
    });
    
    this.registerHealthCheck('cache', async () => {
      return {
        status: 'healthy',
        size: this.userCache.size,
        enabled: this.cacheEnabled
      };
    });
  }
  
  async onInitialize() {
    // Perform initialization tasks
    await this.db.ensureUserTable();
    
    // Record metric
    this.recordMetric('users.initialized', 1);
  }
  
  // Business methods
  async createUser(userData) {
    try {
      // Validate user data
      if (!userData.email) {
        throw new ValidationError('MISSING_EMAIL', 'Email is required');
      }
      
      // Create user in database
      const user = await this.db.users.create(userData);
      
      // Update cache
      if (this.cacheEnabled) {
        this.userCache.set(user.id, user);
      }
      
      // Emit event
      await this.emit('user.created', user);
      
      // Record metric
      this.recordMetric('users.created', 1);
      
      return user;
    } catch (error) {
      await this.handleError(error, {
        method: 'createUser',
        userData
      });
      throw error;
    }
  }
  
  // Event handlers
  async handleUserCreated(event) {
    try {
      // Handle event
      if (this.cacheEnabled) {
        this.userCache.set(event.data.id, event.data);
      }
    } catch (error) {
      await this.handleError(error, {
        event,
        handler: 'handleUserCreated'
      });
    }
  }
  
  async onShutdown() {
    // Clean up resources
    this.userCache.clear();
    
    // Clean up subscriptions
    for (const subId of this.subscriptions) {
      this.eventBus.unsubscribe(subId);
    }
  }
}
```

### Factory Function

```javascript
export function createUserModule(deps = {}) {
  return new UserModule(deps);
}
```

## Module Registration

### Module Registration

```javascript
// In application startup
import { createUserModule } from './modules/UserModule';

async function setupModules(container) {
  const moduleSystem = await container.resolve('moduleSystem');
  
  // Register modules with configuration
  await moduleSystem.register('userModule', createUserModule, {
    userRoles: ['admin', 'user', 'guest'],
    cache: {
      enabled: true,
      ttl: 3600
    }
  });
  
  // Initialize all modules
  await moduleSystem.initialize();
}
```

### Module Resolution

```javascript
// Get a module instance
const userModule = await moduleSystem.resolve('userModule');

// Use module functionality
const user = await userModule.createUser({
  email: 'user@example.com',
  name: 'Test User'
});
```

## Testing Strategy

### Unit Testing Modules

```javascript
describe('UserModule', () => {
  let userModule;
  let mockDatabase;
  let mockEventBus;
  let mockErrorSystem;
  
  beforeEach(async () => {
    // Create mock dependencies
    mockDatabase = {
      users: {
        create: jest.fn().mockResolvedValue({ id: 'user-123', email: 'test@example.com' })
      },
      checkConnection: jest.fn().mockResolvedValue(true),
      ensureUserTable: jest.fn().mockResolvedValue(true)
    };
    
    mockEventBus = {
      emit: jest.fn().mockResolvedValue(true),
      subscribe: jest.fn().mockReturnValue('sub-id'),
      unsubscribe: jest.fn()
    };
    
    mockErrorSystem = {
      handleError: jest.fn()
    };
    
    const mockEventBusSystem = {
      getEventBus: () => mockEventBus
    };
    
    // Create module with dependencies
    userModule = new UserModule({
      database: mockDatabase,
      eventBusSystem: mockEventBusSystem,
      errorSystem: mockErrorSystem,
      config: {
        userRoles: ['admin', 'user'],
        cache: { enabled: true }
      }
    });
    
    // Initialize module
    await userModule.initialize();
  });
  
  afterEach(async () => {
    // Clean up
    await userModule.shutdown();
  });
  
  test('should create a user', async () => {
    const userData = { email: 'test@example.com', name: 'Test User' };
    const result = await userModule.createUser(userData);
    
    // Verify database was called
    expect(mockDatabase.users.create).toHaveBeenCalledWith(userData);
    
    // Verify event was emitted
    expect(mockEventBus.emit).toHaveBeenCalledWith('user.created', expect.objectContaining({
      id: 'user-123'
    }));
    
    // Verify result
    expect(result).toEqual({ id: 'user-123', email: 'test@example.com' });
  });
  
  test('should handle validation errors', async () => {
    const userData = { name: 'Test User' }; // Missing email
    
    // Expect error to be thrown
    await expect(userModule.createUser(userData)).rejects.toThrow('Email is required');
    
    // Verify error was handled
    expect(mockErrorSystem.handleError).toHaveBeenCalled();
    
    // Verify no database call or event
    expect(mockDatabase.users.create).not.toHaveBeenCalled();
    expect(mockEventBus.emit).not.toHaveBeenCalled();
  });
  
  test('should check health', async () => {
    const health = await userModule.checkHealth();
    
    expect(health.status).toBe('healthy');
    expect(health.checks).toHaveProperty('database');
    expect(health.checks).toHaveProperty('cache');
    expect(health.checks.database.status).toBe('healthy');
  });
});
```

### Testing the ModuleSystem

```javascript
describe('ModuleSystem', () => {
  let moduleSystem;
  let container;
  
  beforeEach(async () => {
    // Create container with dependencies
    container = new CoreContainer();
    
    // Register core systems
    container.register('errorSystem', createErrorSystem);
    container.register('config', () => ({}));
    container.register('eventBusSystem', createEventBusSystem);
    
    // Initialize container
    await container.initialize();
    
    // Resolve module system
    moduleSystem = await container.resolve('moduleSystem');
  });
  
  afterEach(async () => {
    // Clean up
    await container.shutdown();
  });
  
  test('should register and initialize a module', async () => {
    // Register a simple module
    class TestModule extends CoreModule {
      async onInitialize() {
        this.initialized = true;
      }
    }
    
    await moduleSystem.register('testModule', TestModule);
    await moduleSystem.initialize();
    
    // Resolve the module
    const testModule = await moduleSystem.resolve('testModule');
    
    expect(testModule).toBeInstanceOf(TestModule);
    expect(testModule.initialized).toBe(true);
  });
  
  test('should resolve module dependencies', async () => {
    // Register modules with dependencies
    class DependencyModule extends CoreModule {}
    
    class DependentModule extends CoreModule {
      static dependencies = ['dependencyModule'];
      
      constructor(deps) {
        super(deps);
        this.dependency = deps.dependencyModule;
      }
    }
    
    await moduleSystem.register('dependencyModule', DependencyModule);
    await moduleSystem.register('dependentModule', DependentModule);
    await moduleSystem.initialize();
    
    // Resolve dependent module
    const dependentModule = await moduleSystem.resolve('dependentModule');
    
    expect(dependentModule.dependency).toBeInstanceOf(DependencyModule);
  });
  
  test('should detect circular dependencies', async () => {
    // Create modules with circular dependencies
    class ModuleA extends CoreModule {
      static dependencies = ['moduleB'];
    }
    
    class ModuleB extends CoreModule {
      static dependencies = ['moduleA'];
    }
    
    // Register modules
    await moduleSystem.register('moduleA', ModuleA);
    await moduleSystem.register('moduleB', ModuleB);
    
    // Initialization should fail
    await expect(moduleSystem.initialize()).rejects.toThrow(/Circular dependency/);
  });
});
```

## Best Practices

### 1. Explicit Dependencies

Always declare dependencies explicitly:

```javascript
class UserModule extends CoreModule {
  static dependencies = ['errorSystem', 'eventBusSystem', 'config', 'database', 'auth'];
  
  constructor(deps) {
    super(deps);
    this.database = deps.database;
    this.auth = deps.auth;
  }
}
```

### 2. Proper Error Handling

Always use `handleError` with context:

```javascript
try {
  await this.database.query('SELECT * FROM users');
} catch (error) {
  await this.handleError(error, {
    operation: 'getUserList',
    context: 'UserModule'
  });
  throw error; // Re-throw or handle as needed
}
```

### 3. Clean Resource Management

Ensure resources are properly managed:

```javascript
async onInitialize() {
  // Allocate resources
  this.connection = await createConnection();
  this.cache = new Cache();
}

async onShutdown() {
  // Release resources
  if (this.connection) {
    await this.connection.close();
  }
  
  if (this.cache) {
    await this.cache.clear();
  }
}
```

### 4. Event-Based Communication

Use events for module-to-module communication:

```javascript
// In UserModule
async createUser(userData) {
  const user = await this.database.createUser(userData);
  await this.emit('user.created', user);
  return user;
}

// In NotificationModule
async setupEventHandlers() {
  this.eventBus.subscribe('user.created', this.handleUserCreated.bind(this));
}

async handleUserCreated(event) {
  await this.sendWelcomeEmail(event.data);
}
```

### 5. Health Monitoring

Implement comprehensive health checks:

```javascript
async onSetupHealthChecks() {
  // Check database connectivity
  this.registerHealthCheck('database', async () => {
    const connected = await this.database.testConnection();
    return {
      status: connected ? 'healthy' : 'unhealthy',
      details: { connected }
    };
  });
  
  // Check cache status
  this.registerHealthCheck('cache', async () => {
    return {
      status: 'healthy',
      size: this.cache.size,
      hitRate: this.cache.getHitRate()
    };
  });
  
  // Check external services
  this.registerHealthCheck('externalApi', async () => {
    try {
      const response = await this.api.ping();
      return {
        status: response.status === 200 ? 'healthy' : 'unhealthy',
        latency: response.latency
      };
    } catch (error) {
      return {
        status: 'unhealthy',
        error: error.message
      };
    }
  });
}
```

## Extending the System

### Custom Module Base Classes

Create specialized module base classes for common functionality:

```javascript
import { CoreModule } from '@core/module/Module';

class ApiModule extends CoreModule {
  static dependencies = [...CoreModule.dependencies, 'router'];
  
  constructor(deps) {
    super(deps);
    this.router = deps.router;
    this.routes = [];
  }
  
  registerRoute(method, path, handler) {
    const route = { method, path, handler };
    this.routes.push(route);
    
    if (this.initialized) {
      this.activateRoute(route);
    }
  }
  
  async onInitialize() {
    // Activate all routes
    for (const route of this.routes) {
      this.activateRoute(route);
    }
    await super.onInitialize();
  }
  
  activateRoute(route) {
    const { method, path, handler } = route;
    this.router[method.toLowerCase()](path, handler.bind(this));
  }
  
  async onShutdown() {
    // Clean up routes if possible
    this.routes = [];
    await super.onShutdown();
  }
}

// Usage
class UserApiModule extends ApiModule {
  async onInitialize() {
    this.registerRoute('GET', '/users', this.getUsers);
    this.registerRoute('POST', '/users', this.createUser);
    await super.onInitialize();
  }
  
  async getUsers(request, reply) {
    // Handle request
  }
  
  async createUser(request, reply) {
    // Handle request
  }
}
```

### Module Decorators

Create decorators to enhance modules:

```javascript
/**
 * Apply caching to a module method
 * @param {string} cacheKey - Key to use for cache entries
 * @param {number} ttl - Cache TTL in milliseconds
 */
function cached(cacheKey, ttl = 60000) {
  return function(target, propertyKey, descriptor) {
    const originalMethod = descriptor.value;
    
    descriptor.value = async function(...args) {
      // Check if module has cache
      if (!this.cache) {
        return originalMethod.apply(this, args);
      }
      
      // Generate cache key
      const key = `${cacheKey}:${JSON.stringify(args)}`;
      
      // Check cache
      if (this.cache.has(key)) {
        const entry = this.cache.get(key);
        if (entry.expires > Date.now()) {
          this.recordMetric('cache.hit', 1, { method: propertyKey });
          return entry.value;
        }
      }
      
      // Execute original method
      const result = await originalMethod.apply(this, args);
      
      // Store in cache
      this.cache.set(key, {
        value: result,
        expires: Date.now() + ttl
      });
      
      this.recordMetric('cache.miss', 1, { method: propertyKey });
      return result;
    };
    
    return descriptor;
  };
}

// Usage
class UserModule extends CoreModule {
  constructor(deps) {
    super(deps);
    this.cache = new Map();
  }
  
  @cached('user', 60000)
  async getUserById(id) {
    return this.database.findUser(id);
  }
}
```

## Areas for Improvement

1. **Module Composition**:
   - Support for module composition through mixins or traits
   - Allow modules to inherit behavior from multiple sources
   - Support more granular feature composition
   - Enable decorator pattern for module enhancement

2. **Dynamic Module Loading**:
   - Support for hot-reloading modules during development
   - Implement dynamic module discovery and registration
   - Add versioning support for modules
   - Support conditional module loading based on configuration

3. **Enhanced Dependency Resolution**:
   - Support for optional dependencies
   - Implement dependency proxies for lazy loading
   - Add interface validation for dependencies
   - Support circular dependencies through proxies

4. **Module Federation**:
   - Support for distributed modules across microservices
   - Implement remote module proxying
   - Create service mesh integration for module discovery
   - Support cross-module communication in distributed setups

5. **Advanced Health Monitoring**:
   - Implement more sophisticated health check aggregation
   - Add anomaly detection for health metrics
   - Create self-healing capabilities for modules
   - Support cascading health status propagation

6. **Improved Testing Support**:
   - Create specialized testing utilities for modules
   - Implement snapshot testing for module configuration
   - Add simulation capabilities for module dependencies
   - Support property-based testing for module interfaces

7. **Performance Optimization**:
   - Optimize module initialization sequence
   - Implement lazy event handler registration
   - Add profiling for module operations
   - Optimize memory usage for module state

8. **Security Enhancements**:
   - Implement module permissions and access control
   - Add audit logging for module operations
   - Support encryption for sensitive module data
   - Implement security scanning for module configurations

